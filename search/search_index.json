{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<p> Welcome to the Virginia Tech AutoBoat Documentation!</p>","text":"<p>This documentation is intended to be a comprehensive guide to everything related to the Virginia Tech AutoBoat software stack. Here, you will find guides on how to set up your development environment, how to install all of the necessary dependencies, how to use actually the software, and explanations of how the software works under the hood.</p> <p></p>"},{"location":"#how-do-i-get-started","title":"<p> How Do I Get Started? </p>","text":"<p>The best way to get started is to follow the Getting Started Guide. This guide will walk you through setting up your development environment, installing all of the necessary dependencies, and running your first mission with the AutoBoat software stack. It is recommended that you follow this guide in order, as it will ensure that you have everything set up correctly before moving on to more advanced topics.</p> <p></p>"},{"location":"#what-frameworks-and-tools-should-i-learn","title":"<p> What Frameworks and Tools Should I Learn? </p>","text":"<p>Note</p> <p>TLDR: You should absolutely be familiar with ROS2 Humble, Git, and how to use a unix shell before you start working on this codebase. You may also want to learn Docker since it is extremely widely used and may be useful to know, but this is not necessary to work on the codebase.</p> <p>Linux/Terminal: Since this codebase is primarily developed and run on Linux based systems (Ubuntu based specifically), it is important to have a basic understanding of how to use a unix shell. This includes understanding basic commands such as <code>ls</code>, <code>cd</code>, <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>mkdir</code>, <code>touch</code>, <code>nano</code>/<code>vim</code>/<code>code</code> (for editing files), and how to run scripts. The more familiar you are with the inner workings of a unix based system, the easier it will be to navigate and understand the codebase. Here are some resources to help you get started:</p> <ul> <li>Linux Command Line Basics</li> <li>Bash Scripting Tutorial</li> </ul> <p>Some people may prefer using Zsh as their shell instead of Bash, which is perfectly fine! Just make sure you understand the basics of whichever shell you choose to use.</p> <p></p> <p>Git: This should be fairly self explanatory, but Git and Github are vital if you want to work on any codebase. It helps us all work on the same codebase at the same time and merge together all of our contributions to the code.</p> <p>Here are the things you should make sure you know how to do before you start working on anything:</p> <ul> <li>Understand the when and how you would use <code>git clone</code>, <code>git add</code>, <code>git commit</code>, <code>git push</code>, <code>git pull</code>, and <code>git fetch</code>.</li> <li>Understand what merging two branches means and how to resolve merge conflicts (preferably in vscode).</li> <li>Understand how to reset to a previous commit by using the commands <code>git reset</code> and <code>git reset --hard</code>.</li> <li>Understand how to create new branches and switch between branches.</li> </ul> <p></p> <p>Python: A large portion of the codebase is written in Python, so it is important to have a basic understanding of the language. This includes understanding basic syntax, data structures (lists, dictionaries, sets, tuples), control flow (if statements, for loops, while loops), functions, classes, and modules. Here are some resources to help you get started:</p> <ul> <li>Python Official Tutorial</li> <li>Automate the Boring Stuff with Python</li> </ul> <p>The language is fairly easy to pick up, so even if you are new to programming, you should be able to get up to speed relatively quickly.</p> <p></p> <p>ROS2: Our techstack utilizes ROS2 (The Robotics Operating System) at its core. Unlike its name implies, it is not an actual operating system, but rather a middleware wrapper that makes concurrency and communication between sensor, actuators, autopilots, and telemetry super easy! This is the industry standard for projects just like this one so if you ever want to do anything in robotics, then this is the framework to learn! The specific version we are using is ROS2 Humble Hawksbill or ROS2 Humble for short, and the documentation for it can be found right here: ROS2 Humble Documentation. Specifically, I would recommend heading to the Tutorials and Concepts sections as those are the most useful for beginners. In addition, there is a really good video series outlining how to get started and do stuff with ROS in addition to the concepts, which can be found here: ROS2 Tutorial Series EP1.</p> <p>Here are the things you should make sure you know how to do before you start working on anything:</p> <ul> <li>Understand what symlink installing a ROS2 package is since this is what we use instead of the traditional ROS2 build system. Another good resource can be found here: symlink install explanation</li> <li>Understand how to create ROS2 Humble packages, nodes, and entrypoints</li> <li>Understand what topics and nodes are and how nodes are able to communicate over topics</li> <li>Understand how to publish and subscribe to topics in code and through the command line</li> <li>Understand what ROS2 timers are and how to create them</li> <li>Understand basic ROS2 commands such as <code>ros2 node list</code>, <code>ros2 node info</code>, <code>ros2 topic list</code>, <code>ros2 topic info</code>, <code>ros2 topic echo</code> etc etc</li> <li>Understand how to run ROS2 nodes, what launch files are, and how to use them</li> </ul> <p></p> <p>Docker: While this isn't much of a framework, it is still an important tool and understanding how it works and the concepts behind it, will make troubleshooting if you ever run into problems a bit easier. Docker is seen pretty much everywhere in software nowadays because its a super streamlined and fast way to create custom virtual machines. It really doesn't matter which part of the software industry you would like to work in in the future, I guarantee you that you will run into docker into some point. So it's better to learn it sooner rather than later! Heres some links to documentation and videos: - Docker Overview - Docker Video Explanation 1 - Docker Video Explanation 2 </p> <p>It turns out that Docker can be used for more than just deployment though. Relatively recently, Docker introduced full support for something called Docker Development Environments (Or Docker Development Containers), which allows us to do all of our development through a Docker container right inside VSCode! Thats great because getting ROS2 and our entire project working on everyone's computers and operating systems was a nightmare to orchestrate and setup, now everyone can just install Docker and our custom development container and start developing instantly! Additionally, there are plenty of other IDEs that support integration with development containers in case you use something other than VSCode; however, VSCode is what we will focus on in this document's setup instructions.</p> <p>Here are some nice things to know about Docker before you start developing. These are nice to know but not necessary:</p> <ul> <li>Understand what containers, images, and devcontainers are</li> <li>Understand how to build an image, run an image (create a container), and how to push images to docker hub</li> <li>Understand simple commands in a Dockerfile and how to make a Dockerfile</li> </ul>"},{"location":"examples/adding_a_new_ros2_node/","title":"<p> Adding a New ROS2 Node to A Package </p>","text":""},{"location":"examples/adding_a_new_ros2_node/#python-nodes","title":"Python Nodes","text":"<p>There are some really good tutorials online found here: Creating a ROS Node Tutorial, What is a ROS Topic, Creating a ROS Publisher Node, Creating a ROS Subscriber Node, and Combining a ROS Subscriber with a ROS Publisher. </p> <p></p> <p>This tutorial series is very good in general, and I would recommend looking at all the videos in the series although it is not strictly necessary.</p>"},{"location":"examples/adding_a_new_ros2_package/","title":"<p> Adding a New ROS2 Package to the Workspace </p>","text":""},{"location":"examples/adding_a_new_ros2_package/#python-packages","title":"Python Packages","text":"<p>To create a new ROS2 python package, you should first run the following command in the <code>/home/ws/src</code> folder:</p> <pre><code>ros2 pkg create &lt;Your Package Name Here&gt; --build-type ament_python --dependencies rclpy\n</code></pre> <p>Once you have created your package, you should see a new folder pop up in <code>/home/ws/src</code> that looks a little bit like this:</p> <p></p> <p>Once you add the package, ensure that you run the following commands:</p> <pre><code>cd /home/ws &amp;&amp; colcon build --symlink-install &amp;&amp; source ~/.bashrc\n</code></pre> <p>This will rebuild the environment to recognize that the new package exists. Without this, ROS2 won't be able to find your new package.</p> <p>A more comprehensive tutorial can be found here: Comprehensive tutorial on how to create a ROS2 python package</p> <p></p> <p>Once you have the ROS2 python package created, you should make your way to the next section on adding new ROS2 nodes, where we will talk about how to add new nodes to ROS2 python packages.</p>"},{"location":"examples/adding_documentation/","title":"<p> Adding Documentation </p>","text":"<p>As a team, we want our software and hardware decisions well-documented and kept in one place to ensure that new members can easily learn the big and complex system they work with, as well as quickly be plugged into development process. As such, after achieving a significant milestone, it is highly recommended to document it and contribute to this website. It is a lot easier than it sounds.</p> <p>To start, install the necessary dependencies. You do not have to do it in docker.</p> <pre><code>pip install mkdocs\npip install mkdocs-material\n</code></pre> <p>mac OS Users</p> <p>We can use brew for this.</p> <pre><code>brew install mkdocs-material\n</code></pre> <p>Then, clone the github repository: <pre><code>git clone https://github.com/autoboat-vt/documentation\n</code></pre></p> <p>You may now make changes to the website code. To edit an existing page, simply find its .md file in <code>docs</code> and edit the text inside. To add a new page, add the file into whichever folder you want it to be (or create a new folder), type it up, and then include in <code>mkdocs.yml</code> under the nav section. The documentation supports html, markdown, and several extensions. You can read about the extensions here.</p> <p>To put your changes on the website, run: <pre><code>mkdocs build\nmkdocs serve\n</code></pre></p> <p>This will set the website to run locally on the <code>http://127.0.0.1:8000/</code> (localhost) IP address. To access it, just type that link in the web-browser.</p> <p>After you feel good about your changes, deploy them to the internet: <pre><code>mkdocs gh-deploy\n</code></pre></p> <p>And don't forget to push them to the github repository!</p>"},{"location":"examples/connecting_a_usb_device_to_wsl/","title":"<p> Connecting a USB Device to WSL </p>","text":"<p>Note</p> <p>If you are on Linux or Mac, USB devices should just work in the dev containers, so you do not need any additional steps</p> <p>Sometimes, we want to test usb devices and their respective ROS nodes before we run them with the Jetson such as the GPS, RC receiver, wind sensor, Raspberry Pi Pico, VESC, etc. Most people run Windows for their personal computer, and unfortunately we have to do some slightly jank things to get everything working on Windows like it would work on the Jetson. One of which is giving USB devices to WSL so that WSL can have full access to read/ write to those USB devices. Unfortunately with how WSL works, USB devices have to belong to either WSL or Windows, so you have to manually give access over to WSL and by default, access is given to Windows.</p> <p></p> <p>Back in the day, we used to have to use a command line tool called usbipd-win, but to put it bluntly, this tool sucks. You have to interact with powershell, manually bind and attach specific devices, and figuring out which device is mounted to which bus were all just annoying. Nowadays, there exists a GUI called WSL USB GUI that simplifies all of the process of binding and attaching a USB device between Windows and WSL.</p>"},{"location":"examples/connecting_a_usb_device_to_wsl/#how-to-install-wsl-usb-gui","title":"How to Install WSL USB GUI","text":"<ul> <li> <p>Go to the following releases page for the WSL USB GUI Tool: Link to WSL USB GUI Releases Page.</p> </li> <li> <p>Click on the .msi release option for Windows:</p> </li> </ul> <p></p> <ul> <li> <p>Run the installer and click through all of the options with the defaults until you have installed WSL USB GUI</p> </li> <li> <p>Once you have finished installing the program, you should see the following show up if you search for WSL USB in the Windows search bar:</p> </li> </ul> <p></p> <ul> <li> <p>Run WSL USB GUI</p> </li> <li> <p>You should see the USB device that is plugged into your computer on here. Simply click on the device and then click \"attach\". Once the device is properly attached to WSL, you should see the device in the forwarded devices tab, and if this is true, that means that WSL can successfully see the USB device!</p> </li> </ul>"},{"location":"examples/how_we_handle_external_libraries/","title":"<p> How to Add External Pip Libraries that We Can Edit</p>","text":"<p>Sometimes, we would like to use external pip packages, but still be able to edit the source code for them on the fly. One great example of this is the pyvesc library for the VESC node, where there are some minor differences between what the library does by default and what we want the library to do. In order to acheieve this, we will take advantage of the \"-e\" option in pip install, which allows us to install a local pip package as editable. Taking the example of the pyvesc library, here is how the source code is laid out:</p> <p></p> <p>Inside of the vesc ros2 package, we have the pyvesc library, which is very similar to the copy of the pyvesc library you can find here: Official pyvesc Library. This is where we would normally like to place our custom pip packages since it is easy to find what pip packages each ros2 package would like to use. Also, whenever you clone a git repository, it generates a folder named .git which contains all of the history of the repository. In short, we don't care about the history of the repository and in fact keeping this file makes it more annoying to use it in our codebase by automatically creating a nested repository. Nested repositories can become a nightmare to deal with, so to make all of our lives easier, just delete the .git folder. You can do so by using the rm -rf command:</p> <pre><code>rm -rf src/vesc/pyvesc/.git\n</code></pre> <p>Now that we have that working, we will need to make it so that we automatically install that package whenever someone runs <code>bash docker_dev_environment_setup.sh</code>. So, we need to add a line into the docker_dev_environment_setup.sh file like so:</p> <p></p> <p>This will automatically install the local pip package in editable mode, so if you make a change in the code of the pip package, then it will automatically reflect in any code that uses that package. If we did not have it in editable mode, then we would need to rebuild the package everytime we make a change to the source code. Now, to install the pip package, simply rerun <code>bash docker_dev_environment_setup.sh</code> and it should be ready to import in any python script inside of the dev container!</p>"},{"location":"examples/running_a_custom_simulation/","title":"<p> Running A Custom Simulation </p>","text":"<p>NOTE: Do Not Clone the Code into Your Docker Development Environment</p> <p>Make sure you clone this repository outside of the Docker development environment, because Docker gets a little fussy with building Docker images inside of a Docker Container, and I would rather not have to deal with that. If you are on Windows, this means that you should do the rest of the setup steps in WSL.</p> <p>See here for information on how to run the default simulation.</p> <p>You should only care about this installation process if you care about modifying and doing direct development on the gazebo simulation. Following these steps will allow you to modify and test a new simulation environment with modified parameters or code.  </p> <p>Before we can build a custom simulation, first we need to clone the autoboat_simulation repository.</p> <p>Open up a terminal in the folder you would like to place the code to build a new simulation in. Next type the following commands:</p> <pre><code>git clone https://github.com/autoboat-vt/autoboat_simulation \ncd autoboat_simulation\n</code></pre> <p>Now that you have all of the code on your computer, there is only 1 dependency for working with the simulation and that is docker-buildx. You can install it like this on Windows WSL and Ubuntu:</p> <pre><code>sudo apt install docker-buildx\n</code></pre> <p>mac OS Users</p> <p>If you are on mac OS, you will need to install docker-buildx using the following command:</p> <pre><code>brew install docker-buildx\n</code></pre> <p>Make sure to follow the instructions that brew gives you after running this command to make sure that docker-buildx is properly installed on your system.</p> <p>Now, all you have to do to build the simulation now is type in the following command:</p> <pre><code>sudo bash build_sim.sh\n</code></pre> <p>And thats it! Now automatically, the simulation node will instead use the new, custom simulation instead of the default. The simulation itself is quite poorly documented so if you have any questions about it and how to do certain things, please ask Chris.</p> <p>If you would like to go back to using the default simulation then all you have to do is delete the simulation docker image and repull the default simulation docker container, the simulation node will pull the default simulation image and build it.</p>"},{"location":"examples/running_individual_nodes/","title":"<p> Running Individual Nodes for Testing </p>","text":"<p>Sometimes it may be preferable to run each node in a separate terminal, so that you can get cleaner debug messages. If you would like to do this, then all of the commands to run each individual node are included in the documentation for that node.</p>"},{"location":"examples/running_simulation/","title":"<p> Running the Simulation </p>","text":"<p>To run the simulation, run the following commands in order after setting up the development container:</p> <pre><code>sudo docker pull vtautoboat/autoboat_simulation:latest\n</code></pre> <p>This command will pull the simulation docker image, which is where all of the simulation work is actually taking place! This command only needs to be run once. Once the docker image has been pulled, you shouldn't need to repull. The command may take a while, but once it is finished, run the following command:</p> <pre><code>ros2 launch /home/ws/src/launch/simulation.launch.py\n</code></pre> <p>This command will then start the simulation and autopilot. Initially, however they won't do anything because they don't have any waypoint commands, so what you will need to do is to type in the following command:  </p> <pre><code>cd /home/ws/ground_station\n</code></pre> <pre><code>./run.sh\n</code></pre> <p>Next, click on \"zoom to boat\". This should show you where the boat is currently located (likely longitude 0 and latitude 0 since this is the default location)</p> <p>Now, click somewhere on the map and then click \"Send Waypoints\". This should cause the boat on screen to start moving and indicates that you have correctly set everything up!  </p>"},{"location":"finances/SEC/","title":"SEC Funding","text":"<p>Work in progress</p>"},{"location":"getting_started/how_to_develop_website/","title":"<p>How to Start Developing on the Website</p>","text":"<p>Our website is hosted using Virginia Tech's website hosting platform called S4 Web Hosting, which can be found here: S4 Web Hosting Link.</p> <p>Since it is impractical to ask Virginia Tech's S4 Web Hosting team to add someone as a developer every time we want to add someone new to the website, we keep a copy of the website code in our Github orgranization. This way someone with access to both repositories can clone our repository to their computer and, using Git, set both the Github and S4 Web Hosting repositories to be \"remotes\" for their local copy of the website code. Then, when we want to push the changes from our Github repository to the S4 Web Hosting repository, we simply push to the S4 Web Hosting remote. This way, we can easily add new developers to the website without needing to ask the S4 Web Hosting team to add them every time.</p> <p>Diagram of the process: Your local computer -&gt; Github repository -&gt; S4 Web Hosting repository</p>"},{"location":"getting_started/how_to_develop_website/#getting-access-to-the-s4-site","title":"<p>Getting Access to the S4 Site</p>","text":"<p>In order to get access to the S4 Site, you need to find someone who already has access to the website and tell them to complete the following steps. (If for any reason you can't contact anyone on the team perhaps because the team has been dormant for some number of years just fill out these steps yourself and hope that the admins allow you to get access to the site)</p> <ol> <li> <p>Since we can't directly add someone as a developer, we need to ask the S4 administrators to add them through a help ticket. Please go to the S4 Web Hosting Site found here: S4 Hosting Site Link, login into your Virginia Tech account if you are not already logged in. If you are not logged in there should be a red button to the right of your screen that says something like \"Login to Request This Service\":    </p> </li> <li> <p>After you have logged in, you should be brought to the following screen with a red button to the right of your screen saying \"Request This Service\":    </p> </li> <li> <p>Once you click that button, you should be brought to a help ticket form, which you should fill out with all of the relevant information. Once filled out it should look something like the following:    </p> </li> </ol> <p>The VT 4help team is usually very responsive and usually will get back to you within a day. Whenever they respond to you, you should receive an email notification, so look out for that.</p> <p>Once the person trying to get access has been approved, they should be able to access the following site: https://code.vt.edu/s4-hosting-sites/aoe/sailbot. If they can't, that means that something went wrong, but if they can then you should move onto the next step.</p>"},{"location":"getting_started/how_to_develop_website/#accessing-the-s4-site","title":"<p>Accessing the S4 Site</p>","text":"<p>In order to access the S4 Web Hosting site (aka code.vt.edu), you need to either setup an SSH key or use a personal access token. It is highly recommended that you setup an SSH key, and you may already be required to do this depending on the classes you are taking/taken.</p>"},{"location":"getting_started/how_to_develop_website/#setting-up-an-ssh-key","title":"<p>Setting Up an SSH Key</p>","text":"<p>See the following link for instructions on how to set up an SSH key: SSH Key Setup Link. If this link has changed or is no longer valid, we recommend you search for \"How to set up an SSH key on GitLab\" and follow the instructions provided by the most reputable source.</p>"},{"location":"getting_started/how_to_develop_website/#creating-a-personal-access-token","title":"<p>Creating a Personal Access Token</p>","text":"<p>If you are unable to set up an SSH key, you can use a personal access token to authenticate yourself. Here are the steps to create a personal access token:</p> <ol> <li> <p>From the website, please click on your profile picture in the top left:    </p> </li> <li> <p>There should be a drop down menu with the button \"Edit Profile\", so please click on that button.    </p> </li> <li> <p>Next, click on \"Personal Access Tokens\" button to the left of the screen.    </p> </li> <li> <p>Next, click the \"Add New Token\" button on the top right of the screen.    </p> </li> <li> <p>Next, enter a name for your token (you can call it whatever you want and it won't matter), and then enter an expiration date (after which time you will have to create another personal access token).    </p> </li> <li> <p>Next, select all of the \"scopes\" to allow this personal access token to do anything with your vt gitlab account (If you actually know what you are doing, then you can limit specific scopes but if you don't worry about it too much).    </p> </li> <li> <p>Once you click the blue \"Create Token\" button at the button of the screen, then you should be redirected to a screen like this:    </p> </li> </ol> <p>At the top of the screen, there is a button to copy the newly created personal access token. If you refresh the page, this button will disappear so make sure you copy the personal access token and keep it somewhere on your computer. You will be asked to provide it whenever you have to push code from your computer to the website GitLab.</p>"},{"location":"getting_started/how_to_develop_website/#git-configuration-for-dual-remotes","title":"<p>Git Configuration for Dual Remotes</p>","text":"<p>Run the following commands on your computer to clone the repository and to set everything up on your computer:</p> <pre><code>git clone https://github.com/autoboat-vt/website &amp;&amp; cd website\ngit remote add aoe_sites https://code.vt.edu/s4-hosting-sites/aoe/sailbot\n</code></pre> <p>Then, whenever you want to push your changes to the gitlab and github, run the following commands:</p> <pre><code>git push origin main\ngit push aoe_sites main\n</code></pre> <p>Running <code>git push</code> on \"aoe_sites\" will deploy the site to the Gitlab (and therefore actually deploy it to the real website) and running <code>git push</code> on \"origin\" will deploy the site to the Github.</p>"},{"location":"getting_started/install_object_detection/","title":"<p> Before Installing Deepstream </p>","text":"<p>Make sure that you have set up the dev container prior to attempting install.</p> <p>General</p> <p>In order to run inference, an NVIDIA 30x series GPU or newer is required.</p> <p>This will not work on macOS and ARM systems.</p>"},{"location":"getting_started/install_object_detection/#installing-deepstream","title":"<p> Installing Deepstream </p>","text":"<p>Inside the dev container, make sure your current working directory is <code>/home/ws/</code>.</p> <p>Execute this script to start the installation.</p> <pre><code>bash install_deepstream_yolo_dev_container.sh\n</code></pre> <p>This installation can take a long time.</p>"},{"location":"getting_started/install_object_detection/#connecting-the-camera","title":"<p> Connecting the Camera </p>","text":"<p>In order to run the object detection module, the Intel RealSense D457 camera must be connected and forwarded to WSL</p> <p>To forward the camera device to WSL, a GUI can be used like WSL USB or these instructions can be followed in Windows Powershell.</p> <p>Making sure the camera is seen in WSL</p> <p>To verify the connection, run this command in the dev container</p> <pre><code>v4l2-ctl --list-devices\n</code></pre> <p>A properly connected camera will have an output similar to this (the numbers may be different)</p> <pre><code>autoboat_user@docker-desktop:/home/ws$ v4l2-ctl --list-devices\nIntel(R) RealSense(TM) Depth Ca (usb-0000:00:14.0-1):\n        /dev/video0\n        /dev/video1\n        /dev/video2\n        /dev/video3\n        /dev/video4\n        /dev/video5\n        /dev/media1\n        /dev/media2\n</code></pre>"},{"location":"getting_started/install_object_detection/#building-a-model","title":"<p> Building a Model </p>","text":"<p>To build a model, navigate to the deepstream_yolo directory. This can be done without a camera connected.</p> <pre><code>cd /home/ws/src/object_detection/object_detection/deepstream_yolo/\n</code></pre> <p>Place the .pt model file in this directory.</p> <p>Run this script to build a .engine model file based on the .pt file. This will take a while.</p> <pre><code>bash build_engine_file.sh &lt;name_of_pt_file&gt;\n</code></pre> <p>What this does</p> <p>In order, what this script does is:</p> <ol> <li> <p>Convert .pt file to .onnx</p> </li> <li> <p>Modify <code>config_infer_primary_yolo11.txt</code> to point to the created .onnx file</p> </li> <li> <p>Create the .engine file</p> </li> </ol> <p>Alternative option</p> <p>This can be split up into separate steps and manually completed</p> <ol> <li> <p>Run <code>python export_yolo11_dev_container.py &lt;name_of_pt_file&gt;</code></p> </li> <li> <p>Manually modify <code>config_infer_primary_yolo11.txt</code>.</p> <p>Comment out lines by adding a '#' in the front.</p> </li> <li> <p>Run <code>python make_model_engine.py</code></p> </li> </ol> <p>labels.txt</p> <p>The <code>labels.txt</code> file is used to tell the vision pipeline what class is which. This is purely a label, and it does not matter if certain classes are missing labels (they will be labeled NULL)</p> <p>In creating the .onnx file, this labels.txt file will be overwritten based on the classes in the model. For most models that we'll make, this probably does not matter.</p>"},{"location":"getting_started/install_object_detection/#running-the-object-detection-module","title":"<p> Running the Object Detection Module </p>","text":"<p>After a model file has been created, you can run the ROS2 object detection module.</p> <pre><code>ros2 run object_detection object_detection\n</code></pre> <p>Annotated images will be saved to <code>/home/ws/src/object_detection/object_detection/frame_results/</code></p> <p>Running without inference</p> <p>The steps to build an engine file can be skipped if inference is not required</p> <p>To do this, set this environment variable before running the module</p> <pre><code>export INFERENCE=false\n</code></pre>"},{"location":"getting_started/installing_docker/","title":"<p> Installing Docker </p>","text":"<p>NOTE: If You Meet Difficulties Installing Docker</p> <p>Ensure that you meet Docker's system requirements listed on their documentation, if not then attempt to contact an officer or look through the Docker documentation for what to do if you do not meet the system requirements.</p> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-windows","title":"<p> Installing Docker on Windows </p>","text":"<p>In order to install Docker on windows, first we must install WSL (Windows Subsystem in Linux).</p> <p>Open the command prompt with administrator privileges and type the following commands:</p> <pre><code>wsl.exe --install -d Ubuntu-22.04\n</code></pre> <pre><code>wsl --set-default Ubuntu-22.04\n</code></pre> <p>Enter your user info to complete the installation.  </p> <p>With these steps, this will have installed WSL and Ubuntu 22.04. Docker requires Ubuntu WSL to work on Windows. For more information see the official WSL documentation: Official WSL Documentation.</p> <p>Next, we must install the Docker desktop application and connect it up to WSL.  </p> <p>The following link contains the download link for Docker desktop on Windows. Follow the download instructions, and when you are done, you should have Docker installed! Docker Desktop for Windows Install Page</p> <p>You may run into permission issues with docker, so you need to run the following commands in your WSL terminal to give your non-sudo user access to Docker.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-ubuntu-linux","title":"<p> Installing Docker on Ubuntu Linux </p>","text":"<p>Please type the following sets of commands in a terminal.</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n</code></pre> <pre><code># Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker\n</code></pre> <p></p>"},{"location":"getting_started/installing_docker/#installing-docker-on-mac-os","title":"<p> Installing Docker on Mac OS </p>","text":"<p>Docker can be installed standalone from the website, but it is recommended to instead install via Homebrew, the unofficial official package manager for Mac OS. Homebrew is recommended over the standalone installer as it simplifies the installation process and is nice to use.</p> <p>Please install Homebrew by entering the following command into the terminal</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Now that Homebrew is installed, run the following command to install Docker Desktop</p> <pre><code>brew install --cask docker\n</code></pre> <p>To verify that the installation was successful, run the following command</p> <pre><code>docker version\n</code></pre> <p>If the installation succeeded, you should get something along the lines of the following</p> <pre><code>\u276f docker version\nClient:\n Version:           27.0.3\n API version:       1.46\n Go version:        go1.21.11\n Git commit:        7d4bcd8\n Built:             Fri Jun 28 23:59:41 2024\n OS/Arch:           darwin/arm64\n Context:           desktop-linux\n</code></pre> <p> </p>"},{"location":"getting_started/installing_docker/#installing-docker-on-other-operating-systems","title":"<p> Installing Docker on Other Operating Systems </p>","text":"<p>Documentation for the rest of the operating systems docker supports can be found here: Official Docker Installation Instructions for Every OS.</p>"},{"location":"getting_started/installing_microros/","title":"<p> Installing MicroROS </p>","text":"<p>To create a layer of protection between Jetson and high voltages, and extend the number of GPIO pins we have access to, we use an RP2040 microcontroller, which communicates via a serial connection. Luckily, we are able to extend our software infrastructure to it through the microros platform. It runs nodes directly on the microcontroller, and then allows them to publish and listen on topics through the USB serial connection. Due to resource-restricted nature of the microcontrollers, the code is written in C and many of the principles when writing nodes for Jetson are inapplicable.</p> <p>To install microros on your machine, run the following command. Note that the installation will take approximately 5 GB:</p> <pre><code>    cd /home/ws/src/microros\n    bash microros_setup.sh\n</code></pre> <p>Don't forget to source your ~/.bashrc file:</p> <pre><code>    source ~/.bashrc\n</code></pre> <p>Note</p> <p>Notice that you need to establish communication between Pi Pico and WSL by USB to flash it. If you are on Windows, download and install the latest release of USB support software from WSL USB GUI Releases. By default, devices are not automatically shared with WSL, so you will need to manually autoattach. For more information, check out the documentation on connecting to a USB device in WSL.</p> <p>To flash Pi Pico with a .uf2 file, plug Pico into your computer while pressing the Boot Select button (you may release it after Pi Pico is in) and run: <pre><code>    picotool_load #write/the/address/of/your/file/here\n</code></pre></p> <p>The Pi Pico cannot communicate with the computer while it is in Boot Select mode. To exit it, you can uplug it and replug it from the USB port. Alretnatively, you may run: <pre><code>    picotool_reboot -F\n</code></pre></p> <p>Then, to establish communication with Pi Pico, run the following commands:</p> <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre> <p>If you encounter problems during the installation, consult Elias.</p>"},{"location":"getting_started/installing_microros/#running-the-example-code","title":"<p> Running the Example Code </p>","text":"<p>If you want to get started with microros, a good idea would be to try to flash Pi Pico with the example file. Note that you would need to build it first: <pre><code>    cd $PICO_MICROROS_SDK_PATH\n    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n    picotool_load pico_micro_ros_example.uf2\n</code></pre></p> <p>Then, proceed to open the serial communication: <pre><code>    sudo chmod 666 /dev/ttyACM0 &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyACM0 -b 115200\n</code></pre></p> <p>And finally, open a new terminal, and type <pre><code>    source ~/.bashrc\n    ros2 topic list\n</code></pre></p> <p>If you have done everything correctly, <code>/pico_publisher</code> would show up in the list of topics. You can watch its output by typing:</p> <pre><code>    ros2 topic echo /pico_publisher\n</code></pre>"},{"location":"getting_started/setting_up_dev_environment/","title":"<p> Before Setting Up the Dev Environment </p>","text":"<p>Make sure that you have installed Docker before doing this step. The following steps will not work if Docker is not installed on your machine. The easiest way to check whether docker is installed correctly, open a terminal and type <code>docker</code>. If an error doesn't pop up that means that you can proceed!</p> <p>mac OS Users</p> <p>In order for the simulation window to appear, you must install XQuartz as macos does not come with a x11 server. Please run the following command in your terminal:</p> <pre><code>brew install --cask xquartz\n</code></pre> <p>After installation, please follow these steps:</p> <ol> <li>Launch XQuartz. Under the XQuartz menu, select Settings.</li> <li>Go to the Security tab and ensure \"Allow connections from network clients\" is checked.</li> <li>Restart XQuartz.</li> </ol> <p>Also ensure that you have VSCode or some other IDE that supports docker dev environments installed (If you are using Windows you install VSCode in WSL as well as on Windows). For the purposes of this documentation, we will be using VSCode but there are plenty of other IDEs that support this and they each have their own documentation for how to get this setup.</p>"},{"location":"getting_started/setting_up_dev_environment/#installing-the-development-container","title":"<p> Installing the Development Container </p>","text":"<p>Windows Users</p> <p>If you are using Windows you must do all of the following commands in the WSL filesystem</p> <p>General</p> <p>Make sure that you have a Docker account and verify your email on that account, because it will ask you for your username and password</p> <p>Next, we need to clone the main Github repository from the following URL: https://github.com/autoboat-vt/autoboat_vt. Open up a terminal and type the following commands:</p> <pre><code>git clone https://github.com/autoboat-vt/autoboat_vt &amp;&amp; cd autoboat_vt\n</code></pre> <p>Then we need to set your computer up to use your display and GPU inside of the devcontainer by running the following command:</p> <pre><code>bash .devcontainer/setup_display_and_gpu.sh\n</code></pre> <p>If the script asks you for your WSL password, please provide it. Once the script finishes running, open up that folder in VSCode by typing the following into the same terminal:</p> <pre><code>code .\n</code></pre> <p>Install the Docker Dev Containers Extension on VSCode. It should look like the following: </p> <p>mac OS Users</p> <p>To test whether or not XQuartz is working correctly, run either <code>xeyes</code> or <code>xclock</code> in your terminal. Your should see a new window appear with one of the following images.</p> <p><p></p></p> <p>If you see one of these images, then XQuartz is working correctly.</p> <p>Build and enter dev container for the repo by typing in the following into the search bar at the top <code>&gt;dev containers build</code>. You should see something similar to this at the top: . Wait for a moment as the container sets itself up!</p>"},{"location":"getting_started/setting_up_dev_environment/#final-setup-after-loading-development-container","title":"<p> Final Setup after Loading Development Container </p>","text":"<p>Once you are inside your development container, you can then open up a terminal by hitting the plus button:</p> <p></p> <p>mac OS Users</p> <p>To test the connection to the Docker container, run the following commands in the terminal in the Docker container:</p> <pre><code>sudo apt-get install -y x11-apps\nxeyes\n</code></pre> <p>If you see a new window with eyes, then the connection is working correctly.</p> <p>Restart VSCode by closing it and reopening it to make sure all of the changes refresh properly.</p>"},{"location":"getting_started/setting_up_dev_environment/#connecting-back-to-the-dev-container","title":"<p> Connecting Back to The Dev Container </p>","text":"<p>If you would like to close the container and resume development on it some other time then heres how you do that. First, open a VSCode window and click on the search bar at the very top. Instead of searching like you would normally, instead type <code>&gt;open folder in container</code>. Remember to include the \"&gt;\" as thats what allows your VSCode search bar to run commands. Once you do that you should get a popup that looks something like this:</p> <p></p> <p>Click on Dev Containers: Open Folder in Container. This should navigate you to a file explorer. Using it, simply navigate to the folder that you cloned the github repo into and you should be back to your development container.</p>"},{"location":"getting_started/what_did_you_just_install/","title":"<p> What is Docker and How Does it Work? </p>","text":"<p>Docker is essentially a way to share custom (super fast) virtual machines. A Dockerfile is the instructions to create these virtual machines. These are then compiled into Docker Images which are the virtual machines stopped at whatever point the Dockerfile told it to stop at. When you run a Docker Image, you get a Docker Container. A Docker Container is the actual virtual machine that you can interact with and work with.  </p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-is-a-development-container-and-why-are-we-using-one","title":"<p> What is a Development Container and Why are We Using One? </p>","text":"<p>A Development Container is a just a Docker Container that already has all of the requirements to start developing, so you can skip setup and not worry about operating system specific software. There are a lot of software packages we rely on and some of the software that we use only works on certain versions on Ubuntu and is really hard to get your hands on with other operating systems. Docker Development Containers automate the process of installing everything by creating a Docker Image with everything installed and running that. This allows you to start developing instantely! Additionally this helps automate and streamline deployment on the Nvidia Jetson microprocessor.</p> <p></p>"},{"location":"getting_started/what_did_you_just_install/#what-about-the-ground-station","title":"<p> What About the Ground Station? </p>","text":"<p>This code is supposed to be run on an operator's computer to control the boat while it is on the water by telling a cloud server what we want our boat to do. The boat (specifically the telemetry node) then listens to this cloud server, processes the data, and performs whatever action we told it to do. You can do various things like sending different parameters to the autopilot and sending waypoints. These parameters can look like the PID gains or the tacking distance or the size of the no go zone etc (in other words things that were chosen arbitrarily).</p> <p>You can also use the ground station code to control the simulation, so if you send waypoints or parameters while a simulation is running then the simulation will automatically listen to the cloud server and navigate to those waypoints/ change specific parameters.</p> <p>For more information on how the ground station sends parameters, please see the telemetry server and groundstation parts of the documentation.</p>"},{"location":"groundstation_telemetry/groundstation_overview/","title":"Groundstation","text":""},{"location":"groundstation_telemetry/groundstation_overview/#introduction","title":"Introduction","text":"<p>This document provides an overview of the Ground Station system, detailing its components, functionalities, and how it integrates with other systems. The Ground Station is a critical part of the overall architecture, enabling communication with the telemetry server and facilitating the management of boat operations. Link to PyQt documentation: PyQt Documentation</p>"},{"location":"groundstation_telemetry/groundstation_overview/#components-overview","title":"Components Overview","text":"<p>NOTE ABOUT EXCEPTIONS IN THE GROUNDSTATION</p> <p>Exceptions thrown in the groundstation do not behave like exceptions thrown in regular Python code. The reason for the exception will not be printed to the console and must be handled in order for the application to continue running. If you have code that you suspect may throw an exception, please enclose it in a try/except block and handle the exception appropriately (ask Barrett if you are unsure how to handle it).</p> <p>All data that persists between runs of the Ground Station and its assets are stored in the <code>app_data</code> directory. I have tried to split up the code in the Ground Station into logical components to make it easier to understand and modify. The Ground Station is divided into the following main components:</p>"},{"location":"groundstation_telemetry/groundstation_overview/#base-components","title":"base components","text":""},{"location":"groundstation_telemetry/groundstation_overview/#mainpy","title":"main.py","text":"<p>This file is the main entry point for the Ground Station application. The code in this file is pretty self-explanatory and will probably only need to be modified if you are adding entirely new functionality to the Ground Station. If you need to know the specifics of what happens in this file, I recommend reading the code itself.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#utils","title":"utils","text":""},{"location":"groundstation_telemetry/groundstation_overview/#constantspy","title":"constants.py","text":"<p>We will begin with the <code>constants.py</code> file, which defines objects that are used throughout the entire codebase. In addition, this file checks for the presence of configuration files and assets that are essential for the Ground Station's operation. The code in this file is the first to be run and is run before the actual application is registered with PyQt. If you have code that will cause the application to crash or not behave correctly when missing assets, it is best to place that code in this file. Additionally, code in this file cannot access properties of the application object created by PyQt. The icons used in the Ground Station are defined in this file, but are not able to be used until the application is registered with PyQt, which happens in the <code>main.py</code> file.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#thread_classespy","title":"thread_classes.py","text":"<p>The <code>thread_classes.py</code> file contains classes that are used to manage threads within the Ground Station application. I decided to places these classes in a seperate file since they don't really feel like widgets, but may be hard to find in the <code>constants.py</code> file if you didn't know they were there. These classes are essential for handling asynchronous operations and ensuring that the Ground Station can perform tasks without blocking the main application thread. I highly recommend reading the code in this file to understand how threads are managed and how they interact with the rest of the application. Online resources on threads and how they work in PyQt may also be helpful if you are trying to work with the code in this file.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#state_managerpy","title":"state_manager.py","text":"<p>The <code>state_manager.py</code> file contains the code that manages the state of key variables in the Ground Station. It is used to make sure that the state of the Ground Station is consistent across all of the different widgets and components. It also provides protection against race conditions and makes sure that the state of the Ground Station is not modified in unexpected ways.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#miscpy","title":"misc.py","text":"<p>The <code>misc.py</code> file contains utility functions that are used throughout the Ground Station codebase. These functions are not specific to any one component and are used in multiple places throughout the code. This file is a bit of a catch-all for functions that don't really fit anywhere else, but are still important for the overall functionality of the Ground Station. If you are looking for a specific function and can't find it in the code where you think it should be, it may be worth checking the <code>misc.py</code> file to see if it is defined there.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#syntax_highlighters","title":"syntax_highlighters","text":""},{"location":"groundstation_telemetry/groundstation_overview/#base_highlighterpy","title":"base_highlighter.py","text":"<p>The <code>base_highlighter.py</code> file contains the base class for syntax highlighters used in the Ground Station. I wanted to take the QSyntaxHighlighter class and write some methods that would make it easier to write syntax highlighters for whatever I needed. The methods in this class are meant to guide the implementation of syntax highlighters so that time is not wasted trying to understand each individual method in the QSyntaxHighlighter class. The methods in this class are not meant to be used directly, but rather to be overridden in subclasses that implement specific syntax highlighting functionality. If you are writing a syntax highlighter for the Ground Station, you should start by subclassing this class and implementing the methods that are relevant to your use case.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#jsonpy","title":"json.py","text":"<p>The <code>json.py</code> file contains a syntax highlighter specifically designed for JSON files. It extends the base highlighter class and implements the necessary methods to provide syntax highlighting for JSON syntax. This highlighter is used to enhance the readability of JSON files within the Ground Station, making it easier to work with configuration files and other JSON data.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#consolepy","title":"console.py","text":"<p>The <code>console.py</code> file contains a syntax highlighter for the console output within the Ground Station. This highlighter is designed to improve the readability of console messages, making it easier to identify important information, warnings, and errors. It uses the base highlighter class to implement specific highlighting rules for console output, ensuring that messages are displayed in a clear and organized manner.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#widgets","title":"widgets","text":""},{"location":"groundstation_telemetry/groundstation_overview/#groundstationpy","title":"groundstation.py","text":"<p>This is the magnum opus of the Ground Station application. It was the first widget I wrote for the Ground Station and is first widget that you see when you open the application. It serves as the main interface for interacting with the Ground Station and allows users to add and remove waypoints and buoys, view telemetry data, and shows popups that that are used to modify the state of the Ground Station. This file also uses some of the classes in the <code>thread_classes.py</code> file to manage asynchronous operations, such as fetching telemetry data and updating the interface without blocking the main thread. If you are looking to understand how the Ground Station works, this is a great place to start.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#instance_handlerpy","title":"instance_handler.py","text":"<p>This widget is used to manage instances of the simulation and the real boat. It provides a way to view info about all available instances, a way to create and delete instances, and a way to connect to an instance. This widget is loaded before the <code>groundstation.py</code> widget and is used to determine which instance the Ground Station should connect to when it starts up.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#popup_editpy","title":"popup_edit.py","text":"<p>This widget is used to create 'windows' that make it easier to modify text in the Ground Station. It takes highligther (such as one of the syntax highlighters defined in the <code>syntax_highlighters</code> directory), some initial text, a tab width, and font size as arguments and uses a QSignal to return the modified text when the user clicks the \"Save\" button or closes the window. This widget is used in the Ground Station to edit buoy data, some data types in the autopilot parameter editor, and the telemetry data 'limits' that are used to determine when a warning or error should be displayed.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#console_outputpy","title":"console_output.py","text":"<p>This widget is used to display the console output of the Ground Station. It uses a QPlainTextEdit to display the output and the <code>console.py</code> syntax highlighter to provide syntax highlighting for the output. It also contains the code that makes it possible to have the console output displayed in the terminal and in the Ground Station at the same time. This is done by using a QThread and some redirection of the standard output streams to capture the console output and display it in the widget.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#graph_viewerpy","title":"graph_viewer.py","text":"<p>This widget is used to display graphs of telemetry data. It uses the PyQtGraph library to create interactive graphs that can display multiple data series at once. The widget also provides functionality to customize the appearance of the graphs, such as changing colors, adding legends, and adjusting the axes. The graph viewer is an important tool for visualizing telemetry data and gaining insights into the boat's performance and behavior.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#map_widget","title":"map_widget","text":"<p>This directory contains the code that is used to make displaying the waypoints and buoys on a interactive map possible. It contains a Go server that is used to manage the transfer of waypoints and buoys between the Python code and the JavaScript code running in the HTML file in this directory. The Go server exposes a <code>get</code> and <code>set</code> endpoint that modifies an array containing the latitude and longitude of the waypoints and buoys which takes the form:</p> <pre><code>[\n    [1.0, 1.0],\n    [2.0, 2.0],\n    [3.0, 3.0],\n    ...\n]\n</code></pre> <p>Where latitude is the first element of each array and longitude is the second element. The JavaScript code in this directory uses the Leaflet library to display the waypoints and buoys on a map.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#camera_widget","title":"camera_widget","text":"<p>This widget is used to display the camera feed from the boat. It uses a QThread from the <code>thread_classes.py</code> file to fetch the camera feed and then runs some JavaScript code to display the feed in a HTML file. We are using an HTML file to display the camera feed because of its abibility to natively show base64 encoded images, saving us the trouble of having to do the decoding ourselves. The widget has buttons that allow you to start and stop the camera feed in order to save bandwidth and processing power when the camera feed is not needed.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#autopilot_config_widget","title":"autopilot_config_widget","text":"<p>This directory contains the widgets that are used to manage the autopilot parameters and configurations. It contains three files: <code>config_editor.py</code>, <code>config_manager.py</code>, and <code>config_widget.py</code>.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#config_widgetpy","title":"config_widget.py","text":"<p>This widget just serves as a wrapper for the <code>config_editor.py</code> and <code>config_manager.py</code> widgets. It is used to display both of these widgets in one tab of the Ground Station. It doesn't contain much code itself, but it is used to manage the layout of the editor and manager widgets and make sure they are displayed correctly in the Ground Station.</p>"},{"location":"groundstation_telemetry/groundstation_overview/#config_editorpy","title":"config_editor.py","text":"<p>This widget is used to manage the autopilot parameters of the boat. It provides a way to view and edit the parameters, as well as a way to save and load parameter configurations. It also allows you to send the parameters to the boat and receive the current parameters from the boat. This widget is essential for tuning the autopilot and ensuring that the boat is performing optimally. An example json file containing autopilot parameters can be found at <code>app_data/autopilot_params/params_default.json</code>. The parameters in this file are not necessarily the best parameters for the boat, but they should be a good starting point for tuning the autopilot. They take the form:</p> <pre><code>{\n    \"param_name\": {\n        \"default\": \"default value of the parameter\",\n        \"description\": \"A description of what this parameter does\",\n    },\n    ...\n}\n</code></pre>"},{"location":"groundstation_telemetry/groundstation_overview/#config_managerpy","title":"config_manager.py","text":"<p>This widget is used to manage different autopilot configurations, both locally and on the telemetry server. It provides a way to view all available configurations, a way to create and delete configurations, and a way to download configurations from the telemetry server into the <code>app_data/autopilot_params</code> directory. This widget is important for keeping track of different parameter configurations and easily switching between them when tuning the autopilot.</p>"},{"location":"groundstation_telemetry/new_member_info/","title":"New Member Overview","text":""},{"location":"groundstation_telemetry/new_member_info/#introduction","title":"Introduction","text":"<p>This document provides information for new members interested in working on either the Ground Station or Telemetry Server components of the Autoboat project. It outlines the necessary skills and knowledge required to effectively contribute to these parts of the codebase, and where to find relevant resources for learning.</p>"},{"location":"groundstation_telemetry/new_member_info/#recommended-skills-and-knowledge","title":"Recommended Skills and Knowledge","text":"<p>To work on the Ground Station or Telemetry Server, you should have a solid understanding (or be willing to learn) the following:</p> <ul> <li>Python Programming: Both the Ground Station and Telemetry Server are written almost entirely in Python. You should be comfortable with Python syntax, data structures, and libraries.</li> <li>PyQt Framework: The Ground Station utilizes the PyQt framework for its graphical user interface. The library is quite extensive, so you don't need to know everything about it, but you should be familiar with the basics of creating windows, widgets, and handling events.</li> <li>Networking Concepts: Understanding basic networking concepts such as sockets, TCP/IP, and data transmission will be beneficial, especially when working with the Telemetry Server.</li> <li>Multithreading: Both components may utilize multithreading to handle concurrent tasks. Its not strictly necessary to be an expert in this area, but a basic understanding of threads and how they work in Python will be helpful.</li> </ul> <p>It's hard to be an expert in all of these areas, so don't worry if you are not. The most important thing is to be willing to learn and ask questions when you need help. You will learn much quicker by doing and asking questions when you get stuck than by trying to learn everything beforehand.</p>"},{"location":"groundstation_telemetry/new_member_info/#learning-resources","title":"Learning Resources","text":"<p>Here are some resources to help you get started with the necessary skills:</p> <ul> <li> <p>Python Programming:</p> <ul> <li>Official Python Tutorial</li> <li>Automate the Boring Stuff with Python</li> </ul> </li> <li> <p>PyQt Framework:</p> <ul> <li>PyQt5 Documentation</li> <li>PyQt5 Tutorial</li> </ul> </li> <li> <p>Networking Concepts:</p> <ul> <li>Python Networking Programming</li> <li>Socket Programming in Python</li> </ul> </li> <li> <p>Multithreading in Python:</p> <ul> <li>Python Threading Module</li> <li>Multithreading in Python Tutorial</li> </ul> </li> </ul>"},{"location":"groundstation_telemetry/new_member_info/#getting-help","title":"Getting Help","text":"<p>If you have any questions or need help getting started, please reach out on the Discord server if you are having trouble with anything. The Discord server is great place to get help since we can only meet in person so often. It is also a good place to hang out with other members of the team, discuss ideas, and participate in some team bonding!</p>"},{"location":"groundstation_telemetry/new_member_info/#next-steps","title":"Next Steps","text":"<p>Once you feel comfortable with the necessary skills and have familiarized yourself with the codebase, you can start contributing to the Ground Station and Telemetry Server components. Here are some suggested next steps:</p> <ul> <li>Take some time to read through the code to learn how the Ground Station and Telemetry Server are structured.</li> <li>Look for small issues or features that you can work on to get familiar with the codebase and development process.</li> <li>Honestly working on the project in any capacity will help you learn faster than anything else, so don't feel like you need to start with something big right away. Just start small and work your way up!</li> </ul>"},{"location":"groundstation_telemetry/telemetry_server_api_routes/","title":"Telemetry Server","text":""},{"location":"groundstation_telemetry/telemetry_server_api_routes/#introduction","title":"Introduction","text":"<p>This document provides an overview of the Telemetry Server API routes, detailing the available endpoints, their functionalities, and how they facilitate communication between the telemetry node and the groundstation. The Telemetry Server API is a critical component of the overall architecture, enabling efficient data exchange and management of boat operations.</p> <p>Diagram showing how each component interacts with each other </p>"},{"location":"groundstation_telemetry/telemetry_server_api_routes/#api-routes-overview","title":"API Routes Overview","text":"<p>The Telemetry Server API is implemented using Python's Flask framework and is hosted on AWS Lightsail.</p> <p>Production URL: <code>https://vt-autoboat-telemetry.uk</code> Testing URL: <code>https://vt-autoboat-telemetry.uk:8443</code></p>"},{"location":"groundstation_telemetry/telemetry_server_api_routes/#routes","title":"Routes","text":""},{"location":"groundstation_telemetry/telemetry_server_api_routes/#autopilot-routes","title":"Autopilot Routes","text":"Method Endpoint Description <code>GET</code> <code>/autopilot_parameters/test</code> Test route for autopilot parameters. <code>GET</code> <code>/autopilot_parameters/get/&lt;int:instance_id&gt;</code> Get the current autopilot parameters for a specific instance. <code>GET</code> <code>/autopilot_parameters/get_new/&lt;int:instance_id&gt;</code> Get the latest autopilot parameters if they haven't been retrieved yet. <code>GET</code> <code>/autopilot_parameters/get_default/&lt;int:instance_id&gt;</code> Get the default autopilot parameters. <code>GET</code> <code>/autopilot_parameters/get_hash/&lt;int:instance_id&gt;</code> Get the hash of the current autopilot parameters for a specific instance. <code>GET</code> <code>/autopilot_parameters/get_config/&lt;config_hash&gt;</code> Get the autopilot configuration for a specific configuration hash. <code>GET</code> <code>/autopilot_parameters/get_hash_description/&lt;config_hash&gt;</code> Get the description for a specific configuration hash. <code>GET</code> <code>/autopilot_parameters/get_all_hashes</code> Get all stored autopilot configuration hashes. <code>GET</code> <code>/autopilot_parameters/get_hash_exists/&lt;config_hash&gt;</code> Check if a specific configuration hash exists. <code>POST</code> <code>/autopilot_parameters/set/&lt;int:instance_id&gt;</code> Set the autopilot parameters using the request data. <code>POST</code> <code>/autopilot_parameters/set_default/&lt;int:instance_id&gt;</code> Set the default autopilot parameters using the request data. <code>POST</code> <code>/autopilot_parameters/set_hash_description/&lt;config_hash&gt;/&lt;description&gt;</code> Set the description for a specific configuration hash. <code>POST</code> <code>/autopilot_parameters/set_default_from_hash/&lt;int:instance_id&gt;/&lt;config_hash&gt;</code> Set the default autopilot parameters using a stored configuration hash. <code>POST</code> <code>/autopilot_parameters/create_config</code> Create a new autopilot configuration from the request data. <code>DELETE</code> <code>/autopilot_parameters/delete_config/&lt;config_hash&gt;</code> Delete a stored autopilot configuration hash."},{"location":"groundstation_telemetry/telemetry_server_api_routes/#boat-status-routes","title":"Boat Status Routes","text":"Method Endpoint Description <code>GET</code> <code>/boat_status/test</code> Test route for boat status. <code>GET</code> <code>/boat_status/get/&lt;int:instance_id&gt;</code> Get the current boat status for a specific instance. <code>GET</code> <code>/boat_status/get_new/&lt;int:instance_id&gt;</code> Get the latest boat status if it hasn't been retrieved yet. <code>POST</code> <code>/boat_status/set/&lt;int:instance_id&gt;</code> Set the boat status using the request data. <code>POST</code> <code>/boat_status/set_fast/&lt;int:instance_id&gt;</code> Set the boat status using a list of values corresponding to the boat status mapping. <code>POST</code> <code>/boat_status/set_mapping/&lt;int:instance_id&gt;</code> Set the boat status mapping for an instance."},{"location":"groundstation_telemetry/telemetry_server_api_routes/#waypoint-routes","title":"Waypoint Routes","text":"Method Endpoint Description <code>GET</code> <code>/waypoints/test</code> Test route for waypoints. <code>GET</code> <code>/waypoints/get/&lt;int:instance_id&gt;</code> Get the current waypoints for a specific instance. <code>GET</code> <code>/waypoints/get_new/&lt;int:instance_id&gt;</code> Get the latest waypoints if they haven't been retrieved yet. <code>POST</code> <code>/waypoints/set/&lt;int:instance_id&gt;</code> Set the waypoints using the request data."},{"location":"groundstation_telemetry/telemetry_server_api_routes/#instance-manager-routes","title":"Instance Manager Routes","text":"Method Endpoint Description <code>GET</code> <code>/instance_manager/test</code> Test route for instance management. <code>GET</code> <code>/instance_manager/create</code> Create a new telemetry instance. <code>GET</code> <code>/instance_manager/get_user/&lt;int:instance_id&gt;</code> Get the user of a telemetry instance. <code>GET</code> <code>/instance_manager/get_name/&lt;int:instance_id&gt;</code> Get the name of a telemetry instance. <code>GET</code> <code>/instance_manager/get_id/&lt;instance_name&gt;</code> Get the ID of a telemetry instance by its name. <code>GET</code> <code>/instance_manager/get_instance_info/&lt;int:instance_id&gt;</code> Get detailed information about a specific telemetry instance. <code>GET</code> <code>/instance_manager/get_all_instance_info</code> Get detailed information about all telemetry instances. <code>GET</code> <code>/instance_manager/get_ids</code> Return all telemetry instance IDs. <code>POST</code> <code>/instance_manager/set_name/&lt;int:instance_id&gt;/&lt;instance_name&gt;</code> Set the name of a telemetry instance. <code>POST</code> <code>/instance_manager/set_user/&lt;int:instance_id&gt;/&lt;user_name&gt;</code> Set the user for a telemetry instance. <code>DELETE</code> <code>/instance_manager/delete/&lt;int:instance_id&gt;</code> Delete a telemetry instance by its ID. <code>DELETE</code> <code>/instance_manager/delete_all</code> Delete all telemetry instances. <code>DELETE</code> <code>/instance_manager/clean_instances</code> Remove all telemetry instances not marked for keeping."},{"location":"hardware/squircuit/","title":"<p> Squircuit </p>","text":"<p>Squircuit is the name of our PCB in development. It is intended to decrease the amount of wiring we have to do. The squircuit contains three buck converters for three different power lines (5V, 9V, and 15~20V), two slots for motor controllers, a relay driver, fuses, and the outputs. The images below show the layout of the entire crcuit as well as the pinout of specifically Pi Pico.</p> <p></p> <p></p>"},{"location":"hardware/wiring_color_scheme/","title":"<p> Wiring Color Schemes </p>","text":"<p>In order to efficiently wire our numerous peripheral devices, we decided to use a coloring standard that will simplify identifying what wire belongs to what interface.</p> Interface Pin Color General Power \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 GND \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 I2C SCL \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SDA \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 UART RX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 TX \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 SPI SCLK \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MISO \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 MOSI \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 CS \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0"},{"location":"misc/crontabs/","title":"<p> Crontabs </p>","text":""},{"location":"misc/crontabs/#what-are-crontabs","title":"<p> What are Crontabs? </p>","text":"<p>Crontabs are simply processes that linux makes run periodically. If we want to run a specific command every 5 seconds, then this is the way to do it. I encourage you to check out the crontabs documentation: Crontab Man Page (Official Documentation) and Third Party Crontab Tutorial.</p>"},{"location":"misc/crontabs/#allowing-devices-to-always-be-accessed-by-non-sudo-users-chmod777jobtxt","title":"<p> Allowing Devices to Always be Accessed by Non-Sudo Users: chmod777job.txt</p>","text":"<p>Lets say, that you would like to test the GPS on your laptop inside of the dev container. You would plug the GPS in and then linux automatically will create a file called /dev/ttyACM01 or some other name for the file that linux decides. We can control what the file is called and override the linux default, but that is outside of the scope of this part of the documentation. Critically, this file represents the GPS, and the only way to communicate and read/ write over the GPS USB port is to access this file. However, by default, you may or may not actually have access to this file as a normal user on the linux system, and sometimes, the only person who has access to this file is the sudo or admin user. So, whenever you would like to communicate with the GPS from your computer and run the GPS node, you will have to run the following command:</p> <pre><code>sudo chmod 777 /dev/**\n</code></pre> <p>This command essentially just steps in as an admin user and says that \"as an admin user, I allow all other users to do whatever they want to the GPS, read or write, I don't care. This is simplifying a little bit, but I hope it gets the point across. Normally, we would need to run this command everytime we plug in the GPS to our computers; however, there is an easier way. We can instead set it up so that this command runs every 0.5 seconds so that when you plug it in, and by the time you try to interact with the GPS, the command will very likely have already been run. This concept applies to all USB devices that you would like to plug into your computer, but I just used the GPS as a simple example.</p>"},{"location":"misc/known_installation_issues/","title":"<p> Known Issues</p>","text":"<ul> <li>In order to get full Intellisense, you need to restart the dev container after building it. Idk how to fix this man but just go with it. The issue might be that the Docker dev environment doesn't register the .vscode folder when it first starts up which is interesting... not sure how I would go about fixing it if thats the issue.</li> </ul> <ul> <li>If the groundstation gives the following error when you boot it up:   then run the following command in a WSL terminal if you are on windows, or on a linux terminal if you are on linux: </li> </ul> <pre><code>echo \"xhost + &gt;&gt; /dev/null\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc\n</code></pre> <p>Explanation for the groundstation error:  your host operating system may not allow you to open x servers from inside of docker because \"technically its a security vulnerability\", but if you have not realized yet, security is our last priority here so we don't care. \"xhost +\" allows anyone to access your x server which lets them do whatever they want to your display, listen to keyboard inputs, etc. This command simply adds \"xhost +\" to your ~/.bashrc file, which is a series of bash commands that are run whenever your terminal opens. Then, the script runs the ~/.bashrc file to apply the changes.  \"&gt;&gt; /dev/null\" simply makes it so that the command doesn't print anything; this is not necessary at all but is nice so you don't have to see the same message everytime you open a terminal. </p> <p></p> <ul> <li>If the simulation is periodically freezing for no discernable reason then the issue is likely your system clock's synchronization, so please ensure that your system clock is synchronized to the internet. A common reason why your system clock may not be synchronized to the internet properly is if you have a dual boot, since dual boots often mess with timezone configurations.</li> </ul>"},{"location":"misc/potential_security_risks/","title":"Heres where I put potential security risks which don't matter at all right now but may matter in the future.","text":"<p>In the future though if we ever want to open source this and release it as a tool for others to use or a product, this would be where to start. - dev container uses docker.sock which needs to have permissions granted to it. So I just do it through ~/.bashrc - <code>autoboat_user ALL=(ALL) NOPASSWD: chmod</code> is appended to /etc/sudoers when building the image. This is not the safest lol</p> <p>Please contact chris (animated__ through discord) if you want to change these things but don't know if we are at a stage where you should/ how to do it</p>"},{"location":"misc/standards_and_definitions/","title":"<p> Standards and Definitions</p>","text":""},{"location":"misc/standards_and_definitions/#units","title":"Units:","text":"<p>Unless stated otherwise, all variables are in SI units (meters, seconds, etc). All measurements of angles by default are in degrees from 0 to 360 degrees. </p>"},{"location":"misc/standards_and_definitions/#definitions","title":"Definitions:","text":"<ul> <li> <p>Autopilot Mode: Autopilot mode typically refers to whether or not the autopilot is in RC control, a semi-autonomous mode like hold heading, or in a full autonomous mode. This is just a string that describes the autopilot mode for the telemetry.</p> </li> <li> <p>Full Autonomy Maneuver: The full autonomy maneuver is only really used for the sailboat in a fully autonomous mode. This describes whether the boat is currently tacking clockwise, tacking counterclockwise, or is normally sailing and navigating towards a specific heading.</p> </li> </ul>"},{"location":"misc/standards_and_definitions/#wind-angle-vector-standards","title":"Wind Angle/ Vector Standards","text":"<p>There are several ways of measuring the wind direction and intensity that are each useful in different situations. The following are the main standards that we have chosen to go with; these exact definitions aren't standard across sailers, and you probably won't even find the words \"Global True Wind Angle\" anywhere online, but we believe that it is useful for our application and hopefully you will see why.</p> <p></p>"},{"location":"misc/standards_and_definitions/#apparent-wind-angle","title":"Apparent Wind Angle","text":"<p>Apparent Wind Angle: The Apparent Wind is the wind measured on top of the boat. Imagine for a second that you are on a speedboat with no wind outside. When the speed boat is moving quickly, then you can feel the wind brush over your face because you are moving quickly even though there is no real wind. This is because you are moving into the air around you, which creates the sensation of wind and works in a similar way to relative motion. The following Youtube video gives a pretty good explanation of apparent wind: Apparent Wind Explanation Youtube Video. The way that we measure this angle is counter-clockwise from the centerline of the boat, which visually looks like this if the boat is facing upwards:</p> <p></p> <p>This means that if the boat is going downwind, then the wind angle is 0 degrees. If the boat is going upwind, then the wind angle is 180 degrees. If the wind is blowing towards the left side of the boat, then the wind angle is 90 degrees. This measurement of the apparent wind direction and speed is really useful for managing the exact position of our sail because the direction that our sail should be pointing is dictated mainly by the apparent wind angle. The exact behaviour of the sail will always be defined by a lookup table, so for instance, if the boat is headed downwind, then the sail should be out all of the way. If the boat is heading directly upwind, then you will want to pull the sails all the way in.  </p>"},{"location":"misc/standards_and_definitions/#how-are-wind-vectors-calculated","title":"How Are Wind Vectors Calculated?","text":"<p>In the next section about the true wind angle, we will talk about the true wind vector and the apparent wind vector, so it may be useful to define them since we have not talked about them before. Whenever we are talking about a wind vector in any standard, the vectors always have a specific definition in relation to their corresponding wind angles and magnitudes and it is the following:</p> <p>\\(\\text{wind_vector_x} = \\text{wind_magnitude} * cos(\\text{wind_angle})\\)</p> <p>\\(\\text{wind_vector_y} = \\text{wind_magnitude} * sin(\\text{wind_angle})\\) </p> <p>This gives some pretty funky results when we start talking about the global true wind angle, but I promise it makes the math easier if you are able to follow along. Here are the x and y axes labeled for the apparent wind angle using this definition of the apparent wind vector:</p> <p></p> <p>This means that the axes that the apparent wind vector are based off of change if the heading/ direction of the boat changes. You have to keep this fact in mind when doing calculations with the apparent wind vector because this is very important.</p>"},{"location":"misc/standards_and_definitions/#true-wind-angle","title":"True Wind Angle","text":"<p>The true wind vector is basically just the wind speed of the location as measured by a stationary sensor, and is just computed by taking the apparent wind vector and adding the local velocity vector of the boat. You must make sure that the velocity vector is measured using the same axes as the apparent wind vector. This is called the local velocity vector and is mentioned in a following section. </p> <p>\\(\\text{true_wind_angle} = \\text{apparent_wind_vector} + \\text{local_velocity_vector}\\)</p> <p>The true wind angle is also measured counter-clockwise from the centerline of the boat just like the apparent wind angle, and the true wind vector has the same base axes as the apparent wind vector. The true wind angle doesn't actually do anything on its own, but it can be used to compute the global true wind angle, which is quite useful for us in plotting courses and in visualizations.</p>"},{"location":"misc/standards_and_definitions/#global-true-wind-angle","title":"Global True Wind Angle","text":"<p>As you may have realized, both of the two previous standards for determining the wind angle are relative to the centerline of the boat and if the direction of the boat changes, then the apparent/ true wind angles will change even if the real wind hasn't shifted. So in order to account for this, we would like to cancel out the direction the boat is facing from the true wind angle. The formula for this is quite simple: </p> <p>\\(\\text{global_true_wind_angle} = \\text{heading_counter_clockwise_from_true_east} + \\text{true_wind_angle}\\) </p> <p>I would encourage you to draw this out and convince yourself of why this fact is true and follows naturally from how we have defined everything so far.</p> <p>This calculation gives us a really good sense of where the wind is actually going regardless of our current heading/ direction and regardless of our velocity vector, which is very useful for displaying wind information to a map and figuring out where the no sail zone is.</p> <p>If you haven't realized already, this definition of the global true wind angle means that the global true wind vector has the x axis defined as true east and the y axis defined as true north. This is very different from the apparent/ true wind vectors so keep that in mind. The apparent/ true wind vector will change if the boat changes directions but the global true wind vector does not change if the boat changes directions.</p>"},{"location":"misc/standards_and_definitions/#global-and-local-velocity","title":"Global and Local Velocity","text":"<p>Similarly to the wind angle, there is a distinction between the global velocity and the local velocity. The global velocity is simply the velocity that the GPS gives us which is measured with the x axis being true east and the y axis being true north. In order to convert this into something where the x axis is the centerline of the boat and the y axis points to the left of the boat, we need to convert to the local velocity which can be done with the following equations:</p> <p>\\(\\text{boat_speed} = \\sqrt{\\text{global_velocity_vector_y}^2 + \\text{global_velocity_vector_y}^2}\\)</p> <p>\\(\\text{global_velocity_angle} = arctan2(\\text{global_velocity_vector_y}, \\text{global_velocity_vector_x})\\)</p> <p>\\(\\text{local_velocity_angle} = \\text{global_velocity_angle} - \\text{heading_angle}\\)</p> <p>\\(\\text{local_velocity_vector_x} = \\text{boat_speed} * cos(\\text{local_velocity_angle})\\)</p> <p>\\(\\text{local_velocity_vector_y} = \\text{boat_speed} * sin(\\text{local_velocity_angle})\\)</p> <p>arctan2 is defined as simply a function that takes in the x and y components of a vector and outputs the angle that vector makes counter-clockwise from the x axis. See the following link for more details: Arctan2 Wikipedia Page</p> <p>Now, similarly to the apparent/ true wind angle, local_velocity_vector_x faces the same direction as the centerline of the boat, and local_velocity_vector_y faces to the left of the boat. This version of the velocity vector can now be added to the apparent wind vector since now both of them are being measured the same way.</p>"},{"location":"misc/systemctl/","title":"<p> What is Systemctl?</p>","text":"<p>Systemctl is essentially a way to schedule scripts to run when a machine starts up, and this is super useful on the Jetson on the actual boat, because it allows us to start up the autopilot ROS nodes without SSH'ing into the Jetson all of the time. Before we started using systemctl, every single time we power cycled the boat, we would have to SSH into the boat and manually run <code>ros2 launch ......</code>, but now with systemctl, this command automatically runs for us everytime the boat starts up.</p>"},{"location":"misc/systemctl/#some-useful-stuff-to-know-how-to-do-in-systemctl","title":"<p> Some Useful Stuff to Know How to Do in Systemctl</p>","text":"<p>Theres a whole bunch of things that are very useful to know how to do with systemctl processes. For example, how to create a new .service file, how to use <code>sudo systemctl enable myservice</code> (which enables the service to start on boot), how to use <code>sudo systemctl start myservice</code> (which starts the service right now), how to use <code>sudo systemctl stop myservice</code> (which stops the service from running right now), <code>sudo systemctl disable myservice</code> (which disables the service to start on boot), and <code>sudo journalctl -u myservice</code> (which shows you the print logs from a specific service).</p>"},{"location":"misc/systemctl/#example-of-a-systemctl-file-that-we-have-used","title":"<p> Example of a Systemctl File That We Have Used</p>","text":"<p>TODO TODO TODO TODO</p>"},{"location":"misc/systemctl/#extra-resources-to-learn-more-about-systemctl","title":"<p> Extra Resources to Learn More About Systemctl</p>","text":"<p>Making a new systemctl process: https://askubuntu.com/questions/919054/how-do-i-run-a-single-command-at-startup-using-systemd</p> <p>Using journalctl: https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs </p>"},{"location":"misc/udev_rules/","title":"<p> What are UDev Rules and How Do We Use Them</p>","text":"<p>Udev Rules allow us to rename specific devices, so that we can very easily access them through code. Devices can usually be found in the /dev/ folder in linux and are generally accessed like devices. For example, a USB device could be found as /dev/ttyACM0, and in order to access that device, you have to provide that specific filepath. However, notice how I said \"could be found\" because this actually depends on the number of USB devices connected to your computer/ Jetson and if your computer/ Jetson is feeling devious today. The USB device could actually be found at /dev/ttyACM1, /dev/ttyACM2, etc etc. In other words, just providing the filepath is unreliable.</p> <p>Thankfully, there is another way to access devices in Linux that is related, but much easier. Essentially, every single serial device on earth is uniquely identified with a 4 digit hexademical number called a VID (vendor ID), a 4 digital hexadecimal number called a PID (product ID), and a serial number. If you know this PID, VID, and serial number, you can search through all of the devices on your computer to try to find the port that corresponds to this specific PID, VID, and serial number to find the port that the device is on. The code for this would look a little something like this:</p> <pre><code>from serial.tools import list_ports\n\ndef getPort(vid, pid) -&gt; str:\n    device_list = list_ports.comports()\n    for device in device_list:\n        if device.vid == vid and device.pid == pid:\n            return device.device\n    raise OSError('Device not found')\n</code></pre> <p>However, this is also not perfect, since we would have to repeat this code throughout every single node that connects to a USB device. Also, this won't actually help us connect to a microros agent that easily, since we need to know the name of the device in /dev/ ahead of time. To solve this and make it a little bit cleaner, we can utilize udev rules. With udev rules, we can give the udev rules a specific VID and PID and then it will automatically rename any device with that VID and PID to \"/dev/gps\" or \"/dev/wind_sensor\" or whatever you want. Here is an example of a udev rule:</p> <pre><code>ACTION==\"add\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6001\", ATTRS{serial}==\"A9001WL3\", SYMLINK+=\"rc\"\n</code></pre> <p>In this example, the USB device has a VID of 0x0403, a PID of 0x6001, and a serial number of A9001WL3. This udev rule will then automatically detect if a device with this VID, PID, and serial number connects to your computer and automatically rename the device to /dev/rc, which makes it super easy to access. </p> <p>In order to make this udev rule actually work, you need to add it to a file like /etc/udev/rules.d/99-autoboat-udev.rules or any other .rules file in the /etc/udev/rules.d folder. Once this line is added to a file in the /etc/udev/rules.d folder, it will automatically take effect. </p> <p>If you wanted to automatically add a udev rule to a file like /etc/udev/rules.d/99-autoboat-udev.rules, then you would just have to run the following command in your linux terminal:</p> <pre><code>sudo echo ACTION==\"add\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6001\", ATTRS{serial}==\"A9001WL3\", SYMLINK+=\"rc\" &gt;&gt; /etc/udev/rules.d/99-autoboat-udev.rules\n</code></pre>"},{"location":"misc/udev_rules/#here-are-some-extra-resources","title":"<p> Here Are Some Extra Resources</p>","text":"<p>https://www.clearpathrobotics.com/assets/guides/kinetic/ros/Udev%20Rules.html</p>"},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/","title":"<p> AutoBoat Messages </p>","text":""},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/#summary","title":"Summary","text":"<p>This package contains various custom messages types that nodes would need to send to each other! Try to add messages to the custom messages library sparingly as we would like most nodes to only publish/ listen with a message type in the base ros2 messages. Here is a list of all of the standard messages that I would recommend using. This keeps our code easily compatible with other peoples' drivers so we can just drop in other peoples' drivers if we ever need to.</p> <p></p>"},{"location":"ros2_packages/autoboat_messages_package/autoboat_msgs/#contains-the-following-messages","title":"Contains the Following Messages","text":"<p>RCData: A standardized way to send RC Data based on the Radiomaster TX12 buttons. Includes both joysticks and all switches/ buttons</p> <p>WaypointList: A list of NavSatFix objects (https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/NavSatFix.html) that represents a list of waypoints. These are passed around and then interpretted by the autopilot to figure out how it should move to get to those waypoints.</p> <p>VESCControlData: Contains all of the data that you need to send in order to command the vesc</p> <p>VESCTelemetryData: Telemetry data from the VESC that gives us feedback about how fast the motor is spinning, how much voltage/ current is being used, etc</p> <p>ObjectDetectionResult: Contains a confidence value and an xy position for the object that the computer vision model found</p> <p>ObjectDetectionResultsList: A list of ObjectDetectionResults</p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/","title":"<p> Autopilot Nodes </p>","text":""},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#summary","title":"Summary","text":"<p>These nodes are responsible for listening to data about the current state of the boat and a set of waypoints and publishing the desired motor behaviour based on our autopilot software. These nodes run completely asynchronously on an internal timer, which means that a few times every seconds it runs a non-blocking script to calculate what the desired motor behaviours should be and publishes them when its done. This node does not actually have code to communicate with motors directly, but instead lets the microcontroller and vesc node figure out the specifics of how to communicate with the motor controllers.</p> <p>Additionally, these nodes publish data that is useful for telemetry and debugging such as the the current maneuver it is attempting to perform and what its desired heading is currently.</p> <p>An important thing to note is that these nodes also control basic RC override, which is why they need to listen into the raw RC data. There are several different types of RC override listed below: </p> <p>Above, you can find all of the different operating modes of the sailboat autopilot, which all depend on the current values of the toggle on the remote controller. The \"toggle\" or 3 way switches on the remote control are the main way that we select which autopilot mode we are in. Autopilot modes describe whether the autopilot is in RC mode, waypoint mission mode, hold current heading mode, etc etc. This encompasses all manner of autonomous and semiautonomous modes, which are useful to easily change from the ground. When the 3 way switch is all the way down (or in other words farthest away from you), then the switch is considered to be in \"state 0\". If the switch is in the middle, it is considered to be in \"state 1\", and if the switch is fully up (or fully towards you) then the switch is considered to be in \"state 2\".</p> <p>The following is an explanation of what all of the current autopilot modes do. In the future, we will likely want to add more of these modes to have different behaviours. </p> <p>Disabled (sailboat + motorboat): The rudder/sail/propeller will not move and the boat is basically limp. This functions pretty much as a kill switch.</p> <p>Full_RC (sailboat + motorboat): The rudder/sail or the rudder/propeller are both controlled by the remote controller.</p> <p>Waypoint_Mission (sailboat + motorboat): The boat will attempt to follow a set of waypoints that are given to it by the groundstation.</p> <p>Hold_Heading (sailboat + motorboat): The boat will attempt to keep the heading that it entered the Hold_Heading mode in with its rudder. For example, if you put the boat in Hold_Heading mode while the boat has a heading of 30 degrees, then the boat will attempt to keep its heading at 30 degrees. The sail/propeller is still controlled by the remote controller.</p> <p>Hold_Best_Sail (sailboat): The boat will attempt to hold the best sail angle. Generally, for every state the boat is in, there is an optimal angle to hold the sail at. For more information, check out the Sailboat Autopilot Documentation. The rudder is still controlled by the remote controller.</p> <p>Hold_Heading_And_Best_Sail (sailboat): the boat will attempt to do Hold_Heading and Hold_Best_Sail at the same time.</p> <p></p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#the-autopilot-parameters-system","title":"The Autopilot Parameters System","text":"<p>In order for us to be able to control and tune parameters for the autopilot from the groundstation, these nodes also listen for autopilot_parameters. These are jsons (serialized as strings) which detail all of the new parameters and what their values should be. These values are sent from the groundstation to the telemetry server, then to the telemetry node and then finally to the autopilot (a diagram of how exactly this is done can be found in the system diagrams). An example of these parameters is shown below:  </p> <p>Not all of the parameters need to be included in the json. If only some of the parameters are included, then only those parameters will get changed in the autopilot. The default parameters can be found in the config folder and whenever a parameter is not specified by the groundstation, it will default to the parameter values found in the config folder. Also, the default parameter files in the config folder represent all of the parameters that the autopilot can accept, so if you are ever curious about which parameters you can change in the autopilot, then please check out the default parameters files.</p> <p></p>"},{"location":"ros2_packages/autopilot_package/common_documentation_between_the_motorboat_autopilot_and_the_sailboat_autopilot/#choosing-the-correct-rudder-angle","title":"Choosing the Correct Rudder Angle","text":"<p>One of the tasks that the autopilot aims to do is to choose the correct rudder angle, so that our boats can follow a certain heading. A lot of the time, this isn't so simple because of how non-linear this problem ends up being. So, we choose to use a PID controller to be flexible enough to handle non-linearity, while still having the option to revert back to a simple proportional controller. </p> <p></p> <p>If you are lost on any of the controls terminology, then I would recommend that you look at some of the following resources: Proportional Controller Tutorial and PID Controller Introduction. These resources are just a start, and if you would like to work on the autopilot, I would highly recommend you look more into basic control theory and become intimately familiar with how these work. </p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#what-is-the-should_propeller_motor_be_powered-topic","title":"What is the should_propeller_motor_be_powered topic?","text":"<p>This topic basically turns off a contactor that denies power to the propeller motor. This is implemented for safety, since we would like to know whether the high voltage system and the propeller motor is live whenever we want to swap out propellers or move the boat. </p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#why-does-the-autopilot-node-control-whether-the-contactor-should-be-closed-cant-the-raspberry-pi-pico-directly-receive-rc-data-and-then-control-the-contactor","title":"Why does the Autopilot Node Control Whether the Contactor Should be Closed. Can't the Raspberry Pi Pico Directly Receive RC Data and then Control the Contactor?","text":"<p>We would like the contactor to be controlled by RC command primarily, but we would also like to support the idea that in the future, we may want the autopilot to complete a route, and then unpower itself so that we can take it out of the water safely without having to manually depower it via RC. Another reason is that the raspberry pi pico code is a little harder to change, and if we wanted to change which toggle the contactor switch/ kill switch would be tied to (or really any of the RC buttons), we could theoretically do that through autopilot parameters and the groundstation. This is ideal, but also not implemented yet. Also, if we must make the decision that the raspberry pi pico must listen to the RC data topic at all, that means that there will be a lot of serial port traffic over the usb port to the raspberry pi pico, since the jetson needs to send the entirety of the RC data struct many many times per second. This may eat up CPU time on both the Jetson and the Pico and make them both less responsive (sort of). The CPU time is kind of a pedantic reason and really we would want to benchmark and see whether this actually makes any meaningful difference.</p> <p>TLDR: this is kinda just how I chose to do it since all of the other RC functions are described in the autopilot and all of the reasons above are retroactive cope</p> <p></p>"},{"location":"ros2_packages/autopilot_package/motorboat_autopilot/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot motorboat_autopilot\n</code></pre>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/","title":"<p> Sailboat Autopilot </p>","text":""},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#choosing-the-best-sail-angle","title":"Choosing the Best Sail Angle","text":"<p>As it turns out, for any apparent wind angle, there is an optimal sail angle that you should turn the sail to. This is perhaps the only simple thing about the autopilot. There are plenty of diagrams such as the one below that demonstrate what those optimal sail angles are: </p> <p></p> <p>As long as the sail angle follows this pattern for the sail angle, then the boat will be moving the fastest in that direction. To accomplish this, we use a lookup table that linearly interpolates between the optimal sail angles given in the sail lookup table (which is described in the autopilot parameters):</p> <p> </p> <p>The code works by taking the two closest wind angles and their corresponding closest sail angles, then we construct a line out of that and figure out where we fall along that line. This is called linear interpolation. </p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-do-we-sail-upwind","title":"How Do We Sail Upwind?","text":"<p>You may be wondering, how is the boat able to sail slightly upwind in the sailing diagram. Well, this is a neat quirk of sailing that is the entire reason why sailing is even possible in the first place. If we are able to hold an angle right outside of this \"no sail zone\", then we are able to gain some ground going upwind, and if we can go in a zig zag motion upwind, then we are able to move upwind and not make any net progress to the side. Here is a video that visually explains how it works: Sailing Tutorial Video. Skip to 23:00 if you want the tacking explanation, but the entire video is pretty good, so I would recommend watching all of it.</p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-do-we-determine-when-to-tack","title":"How Do We Determine When to Tack?","text":"<p>A very simple way to tack is to check whether the waypoint is in the no sail zone. If the waypoint is in the no sail zone, then keep a close hauled position (it doesn't matter too much whether you keep close hauled to the left of the waypoint or to the right of the waypoint). The boat will then keep that close hauled position until the waypoint goes out of the no sail zone, and then the boat will tack towards the waypoint and successfully capture the waypoint. This method will ensure that the boat will have to tack exactly once to get to its destination. A visual represntation of what this looks like is shown below:</p> <p></p> <p>To determine when to tack, we have to introduce a concept called decision zones. This concept doesn't really exist anywhere online because we invented it for autonomous tacking. Essentially if we create another zone inside of the nogo zone called the decision zone and pay attention to the line between the boat and the next waypoint, then whenever the line between the boat and the next waypoint is in \"zone 1\" then we should hold a tack on the left side of the wind. Whenever the line between the boat and the next waypoint is in \"zone 3\" then we should hold a tack on the right side of the wind. Finally, if the line is in zone 2, you should continue holding the tack that you were previously holding. A visual representation of the decision zone and what a path when using decision zone tacking can both be found below:</p> <p></p> <p></p> <p>So then that begs the question, how large should the decision zone be. Well a couple of years ago, we had some team members derive the theoretically optimal decision zone size if you want to go a specific distance before tacking. This formula can be found below:</p> <p></p> <p>This formula is not perfect and can often be very wrong due to factors like noisy sensor data, the wind shifting, the boat drifting due to water currents, etc; however, it provides a good baseline for us to use in our algorithm.</p> <p>Using the decision zone tacking strategy and constantely updating the size of our decision zone, we can efficiently sail upwind!</p> <p></p>"},{"location":"ros2_packages/autopilot_package/sailboat_autopilot/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot sailboat_autopilot\n</code></pre>"},{"location":"ros2_packages/autopilot_package/telemetry/","title":"<p> Telemetry </p>","text":""},{"location":"ros2_packages/autopilot_package/telemetry/#summary","title":"Summary","text":"<p>This node is responsible for listening to various topics and sending the data to the telemetry server so that we, with the groundstation, can view the data. Additionally, this node is also responsible for listening to autopilot parameters and waypoints stored in the telemetry server and sending them to the autopilot node. This allows us to change parameters of the autopilot and change the waypoints the boat needs to follow from the shore.</p> <p>The telemetry node listens to data about the boats current state such as the position, velocity, heading, apparent wind vector. It also listens in on data that lets us know what the autopilot is currently thinking such as the current sail/ rudder angle, the heading it is trying to sail towards, a list of all of the waypoints that it is trying to follow, an index that represents what waypoint the autopilot is currently on, the name of the mode the autopilot is currently on (whether it is in RC mode, full autonomy mode, or some semi-autonomous mode), and the maneuver the boat might be trying to perform if it is in full autonomous mode (like tacking/jibing).</p> <p>The telemetry node will coalesce all of this information into a single json, and send that json over to the telemetry server. The telemetry server will then pass that data along verbatim to the groundstation, so the groundstation can properly interpret that data.</p> <p>The reason that this is a separate node from the autopilot nodes is that we would ideally like to have the option to run the autopilot without a WiFi connection, so if the telemetry code is in its own node, then we can just choose to not launch the telemetry node, and it should work perfectly!</p> <p>If you would like more information on the telemetry node and what information it receives and how it communicates with the telemetry server/ groundstation, please see the ros system diagrams and the system diagram specifically for the groundstation/ telemetry.</p> <p>If you would like to learn more about the specific https routes that are available in the telemetry server and what their role is, then please refer to the telemetry server documentation.</p> <p></p>"},{"location":"ros2_packages/autopilot_package/telemetry/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run autopilot telemetry\n</code></pre>"},{"location":"ros2_packages/microros_package/microros/","title":"<p> Microros </p>","text":""},{"location":"ros2_packages/microros_package/microros/#summary","title":"Summary","text":"<p>This is the main package for MicroROS development. Due to the nature of microcontrollers, only one package can be run on a Pi Pico. However, there are few limitations as to how many nodes can be run. Since the RP2040 chip installed on Pi Pico has two cores, we can even run some of the nodes in parallel, taking full advantage of multithreading. All of the nodes will be documented in this file. To get started with microros development, check out Installing MicroROS in misc.</p> <p>All the nodes, their common resources, execution order, and scheduling are managed in the main.c file in the src folder. If you want to add a .c file with a node, as well as in add_executable section in CMakeLists.txt. Depends on if you include new libraries you might want to add them in CMakeLists.txt too. Important libraries and ports are located in common_microros_libs.h, which is preferable to include in each file within src folder. If you need to define ports or pins, UART for example, you do it there. To build an already existing project, execute the following commands inside <code>/microros/</code> (not <code>/microros/src/</code>): <pre><code>    mkdir build &amp;&amp; cd build\n    cmake ..\n    make\n</code></pre> From here on, after making changes to the code, you can build it simply by running <code>make</code>. Next steps, such as opening communication with ROS or flashing Pico are detailed in Installing MicroROS. </p> <p></p>"},{"location":"ros2_packages/microros_package/microros/#how-to-run","title":"How to Run","text":"<pre><code>sudo chmod 777 /dev/** &amp;&amp; ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/pico -b 115200\n</code></pre>"},{"location":"ros2_packages/microros_package/unittests/","title":"Unit tests with Catch2","text":"<p>These are the instructions to build the Pico SDK and Catch2 unit tests on Windows. To set up, run <code>source /opt/ros/humble/setup.bash</code> in the devcontainer.</p>"},{"location":"ros2_packages/microros_package/unittests/#building","title":"Building","text":"<p>Run the following in the devcontainer.</p>"},{"location":"ros2_packages/microros_package/unittests/#without-unit-tests","title":"Without Unit Tests","text":"<p><pre><code>cmake -B build -S src/microros\ncmake --build build\n</code></pre> Output: <code>build/pico_microros.uf2</code> Upload this to your Pico.</p>"},{"location":"ros2_packages/microros_package/unittests/#with-unit-tests","title":"With Unit Tests","text":"<pre><code>cmake -B build_unit_tests -S src/microros -DBUILD_UNIT_TESTS=ON\ncmake --build build_unit_tests\n</code></pre> <p>Output: <code>build_unit_tests/unit_tests</code></p>"},{"location":"ros2_packages/microros_package/unittests/#interfacing","title":"Interfacing","text":"<p>In Windows, we need to pass the Pico to WSL. Skip this step on Linux. Execute <code>usbipd list</code> in an elevated PowerShell to get your Pico's BUSID.</p> <p>The Pico will be the line containing 2e8a. We need to attach the Pico to WSL. </p> <pre><code>usbipd bind --busid &lt;BUSID&gt;\nusbipd attach --wsl --busid &lt;BUSID&gt;\n</code></pre> <p>Start the MicroROS agent in a new WSL terminal: <code>docker run -it --rm -v /dev:/dev --privileged --net=host microros/micro-ros-agent:humble serial --dev /dev/&lt;Pico path&gt; -b 115200</code></p>"},{"location":"ros2_packages/microros_package/unittests/#running-the-tests","title":"Running the tests","text":"<p>Run <code>./build_unit_tests/unit_tests</code> in the devcontainer</p>"},{"location":"ros2_packages/microros_package/unittests/#adding-new-tests","title":"Adding New Tests","text":"<p>Edit <code>src/microros/src/unittests.cpp</code> and add new <code>TEST_CASE</code> blocks:</p> <pre><code>TEST_CASE(\"My new test\", \"[test][pico]\") {\n    PicoInterface pico;\n\n    // Wait for connection\n    std::this_thread::sleep_for(2000ms);\n    rclcpp::spin_some(test_node);\n\n    // Your test logic here\n\n    REQUIRE(true);\n}\n</code></pre>"},{"location":"ros2_packages/microros_package/unittests/#executing-your-tests","title":"Executing your tests","text":"<p><code>./build_unit_tests/unit_tests</code></p> <p>This will output if your tests passes or not.</p>"},{"location":"ros2_packages/microros_package/unittests/#troubleshooting","title":"Troubleshooting","text":"<p>Rebuild tests: <code>cmake --build build_unit_tests</code> in the devcontainer CLI Check ROS 2 topic visibility: <code>ros2 topic list</code> in the devcontainer</p>"},{"location":"ros2_packages/new_simulation_package/motorboat_simulation/","title":"<p> Motorboat Simulation </p>","text":""},{"location":"ros2_packages/new_simulation_package/motorboat_simulation/#summary","title":"Summary","text":"<p>This simulation node wraps around a Gazebo Harmonic (a general purpose physics simulator) simulation of a motorboat traveling in a free plane of water. The simulation is currently contained in the <code>andrews-cool-simulation</code> branch in github, but at the time of reading this, it may have been pushed to main.</p> <p>The ros node acts as a translator from ros messages to gazebo messages, which the simulation publishes/subscribes to to control the motorboat. The node sends messages such as rudder angle and thrust, and it receives the boat's position, heading, velocity, true rudder angle, true thrust, etc.</p>"},{"location":"ros2_packages/new_simulation_package/motorboat_simulation/#how-to-run-it","title":"How to Run It","text":"<p>At the moment, the simulation is still on a separate branch in the github. Switch to the <code>andrews-cool-simulation</code> branch and rebuild the container. You'll need to build the custom plugins the first time you switch to the branch, which can be done manually or with the <code>rebuild_plugins.sh</code> script in <code>src/motorboat_sim_testing</code>.</p> <p>To run the simulation alone, run: </p> <pre><code>cd /home/ws/src/motorboat_sim_testing\ngz sim buoyant_cylinder.sdf\n</code></pre> <p>To run the ros node, run:</p> <pre><code>cd /home/ws/src/launch\nros2 launch simtest.launch.py\n</code></pre>"},{"location":"ros2_packages/new_simulation_package/motorboat_simulation/#how-it-works","title":"How it Works","text":"<p>The gazebo simulation for the motorboat is contained in <code>buoyant_cylinder.sdf</code>. These sdf files are essentially JSON written differently, for which the full sdf spec can be found here: sdformat specification. The file is a combination of basic data, the shape, mass, initial position, and inertia of all the elements plus the joints that connect them, and plugins, some of which are built-in to gazebo and some of which we wrote ourselves.</p> <p>The file starts with various scenery/light/camera/physics parameters, most of which are fairly standard. Some notable built-in plugins here are <code>gz-sim-user-commands-system</code>, which allows us to send gazebo commands (which are sent from the ros node) to control the simulation. The <code>gz-sim-navsat-system</code> gives the positional data that the autopilot expects. Below, the model <code>my_ship</code> is the boat, which is where the real meat of the program is. Here is where every piece of the boat is defined, with all the plugins that allow our boat to move!</p> <p>First, the boat's parts are mostly life-scale, with the measurements being taken from the most recent boats on hand and the masses being estimated. Notably, the boat's hull is split into four pieces because of the buoyancy plugin, which only acts at the center of mass because it's terrible. The inertia tensors are calculated manually, either from a formula or solidworks. A description of the inertia tensors can be found here and in the sdformat specification.</p> <p>Here are the notable built-in plugins:</p> <ul> <li><code>gz-sim-joint-position-controller-system</code> - This is what controls the rudder</li> <li><code>gz-sim-odometry-publisher-system</code> - Publishes position and velocity messages</li> <li><code>gz-sim-thruster-system</code> - This is what controls the thruster</li> <li><code>gz-sim-hydrodynamics-system</code> - Description below in the How to Develop section</li> </ul> <p>Here are our custom plugins:</p> <ul> <li><code>libRudderDynamics.so</code> - This is our custom LiftDrag plugin. The built-in one is terrible. At some point, this should probably be renamed. In this case, clmax and cdmax refer to the equations of coefficient of lift and coefficient of drag. These coefficients, when plotted vs. angle of attack, form vaguely sinusoidal curves, so find the coefficient of lift vs alpha (aoa) curve for whatever shape/material you're using, then put the max in. For more details, look up more about lift/drag forces.</li> </ul>"},{"location":"ros2_packages/new_simulation_package/motorboat_simulation/#how-to-develop","title":"How to Develop","text":"<p>The first thing I'd like to mention is to avoid using AI. I know it's easier, but LLMs are very bad with gazebosim and the ros gazebo bridge since the documentation is terrible and there are so few examples online that use Gazebo Harmonic.</p> <p>To develop on the ros node (contained in <code>simtest.launch.py</code>), you need to understand ros and python, for which there are tutorials elsewhere in this documentation. To develop on the gazebo sim, you need to understand gazebo harmonic and the format of sdf files. The current simulations are good examples, but the documentation can be found here: Gazebo Harmonic Tutorials. The list of built in plugins can be found here: Gazebo 8.10.0 Systems Documentation. Some of the plugins there have terrible documentation, so you may need to look elsewhere for examples. Notably, the hydrodynamics plugin has a great explanation here: Gazebo Hydrodynamics Plugin. If you want to know what the inputs to the hydrodynamics plugin mean, I'd recommend checking out Fossen, Thor I. Guidance and Control of Ocean Vehicles. United Kingdom: Wiley, 1994 as mentioned in the documentation. You can find it in Newman Library or the Ocean Engineering lounge (allegedly).</p> <p>All gazebo plugins are written in C++, so you will need to be able to at least read C++ to work with them. Additionally, at some point when using the built in plugins, you will need to check the source code. It can be found here.</p> <p>As to our custom plugins, they are written in C++ and take the following form:</p> <pre><code>plugin_name\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 include\n\u2502   \u2514\u2500\u2500 PluginName.hh\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 PluginName.cc\n</code></pre> <p>To rebuild the plugin, you can simply enter the build folder and run <code>make</code>. If you altered the CMakeLists.txt, run <code>cmake ..</code> in the build folder first.</p> <p>To create a custom plugin, the documenation can be found here: Gazebo plugin documentation. Most plugins you will need to make will run at PreUpdate time.</p> <p>Let's examine RudderDynamics to get an idea of what is necessary in a plugin:</p> <pre><code>#include \"../include/RudderDynamics.hh\"\n#include &lt;cmath&gt;\n\nnamespace rudder_dynamics\n{\n\n/////////////////////////////////////////////////\nRudderDynamics::RudderDynamics()\n: rho_(1000.1),\n  cp_(0, 0, 0),\n  forward_(1, 0, 0),\n  upward_(0, 0, 1),\n  area_(1.0),\n  clmax_(1.5),\n  cdmax_(1.0)\n{\n  RCLCPP_INFO(rclcpp::get_logger(\"RudderDynamics\"), \"RudderDynamics plugin constructed\");\n}\n\n/////////////////////////////////////////////////\nRudderDynamics::~RudderDynamics() = default;\n\n/////////////////////////////////////////////////\nvoid RudderDynamics::Configure(const gz::sim::Entity &amp;_entity,\n                             const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                             gz::sim::EntityComponentManager &amp;_ecm,\n                             gz::sim::EventManager &amp;)\n{\n  if (_info.paused)\n    return;\n</code></pre> <p>Every plugin is not required to have its own namespace, it's just the convention we use. The <code>RCLCPP_INFO(rclcpp::get_logger(\"RudderDynamics\"),</code> is how to send logs to the console. The <code>if (_info.paused)</code> is very important, as your plugin will keep running when the simulation is paused if it's not there, which will probably break it!</p> <pre><code>// Get world linear velocity\nauto optVel = links_[0].WorldLinearVelocity(_ecm);\nif (!optVel)\nreturn;\ngz::math::Vector3d vel = *optVel;\n\n// Get world pose\nauto optPose = links_[0].WorldPose(_ecm);\nif (!optPose)\nreturn;\ngz::math::Pose3d pose = *optPose;\n</code></pre> <p>Gazebo has its own math plugin, which can be found at the Gazebo math github. The documentation can be found here: Gazebo math documentation. A cool steam game called Gazebo Simulator can be found here.</p> <pre><code>/////////////////////////////////////////////////\nGZ_ADD_PLUGIN(rudder_dynamics::RudderDynamics,\n              gz::sim::System,\n              rudder_dynamics::RudderDynamics::ISystemConfigure,\n              rudder_dynamics::RudderDynamics::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(rudder_dynamics::RudderDynamics, \"rudder_dynamics::RudderDynamics\")\n</code></pre> <p>The specific methods you put into <code>GZ_ADD_PLUGIN</code> depend on which methods you implemented. The .hh files are mostly self explanatory, if you understand C++, you should be alright with those. As for the CMakeLists.txt and package.xml, you'll need some required packages for gazebo, and the package.xml has to be there to run <code>cmake ..</code>.</p> <p>TLDR: 1. create folder with build, src, and include folders 2. create header and source file and create CMakeLists.txt and package.xml 3. run \"cmake ..\" and \"make\" in the build folder 4. fix all the errors bc ur bad at programming 5. add the path to the build folder to GZ_SIM_SYSTEM_PLUGIN_PATH in .bashrc, which means you need to edit postCreateCommand.sh 6. add the plugin to your sdf!</p>"},{"location":"ros2_packages/object_detection_package/object_detection/","title":"<p>Object Detection</p>","text":""},{"location":"ros2_packages/object_detection_package/object_detection/#summary","title":"Summary","text":"<p>This node detects buoys and boats on the water and estimates their bearing (angle) and range (distance). Detection is powered by an Ultralytics YOLOv11 model. We use the Ultralytics <code>results</code> object to retrieve bounding boxes, classes, and confidences.</p> <p>The node runs on ROS 2 and publishes: - Bearing to target (angle) \u2014 relative to the camera/boat frame. - Range to target (depth distance) \u2014 from depth data or geometric approximation. - Per-detection metadata \u2014 confidence score, relative x/y of the bounding box, etc.</p>"},{"location":"ros2_packages/object_detection_package/object_detection/#what-it-publishes","title":"What it publishes","text":"<ul> <li><code>sensor_msgs/msg/Image</code></li> <li><code>sailbot_msgs/msg/ObjectDetectionResults</code></li> <li><code>detections[]</code>: <code>{ confidence value, x_postion, y_position}</code></li> </ul> <p>QoS is configurable via <code>QoSProfile</code> and should be tuned to match the camera publisher (e.g., <code>RELIABLE</code> vs <code>BEST_EFFORT</code>, <code>KEEP_LAST</code> depth, etc.).</p> <p></p>"},{"location":"ros2_packages/object_detection_package/object_detection/#repository-models-dataset","title":"Repository (Models &amp; Dataset)","text":"<p>The code, models, and dataset live on Hugging Face (handles large files better than GitHub):</p> <p>Object Detection \u2013 Hugging Face Repository: https://huggingface.co/datasets/Aanimated/autoboat_vt_object_detection/tree/main</p> <p>We use a Hugging Face dataset repo because it supports large images and model weights via Git LFS. You can clone it and pull all LFS-tracked files locally.</p>"},{"location":"ros2_packages/object_detection_package/object_detection/#quick-start","title":"Quick start","text":"<pre><code># Install Git LFS, clone, and pull large files\nsudo apt update &amp;&amp; sudo apt install -y git-lfs\ngit lfs install\n\ngit clone https://huggingface.co/datasets/Aanimated/autoboat_vt_object_detection\ncd autoboat_vt_object_detection\ngit lfs pull\n</code></pre>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/","title":"<p> TLDR </p>","text":"<p>For all the other nodes in the repository, don't worry about them for now. They are likely just tests or very highly under development. Either way you shouldn't worry about them on a conceptual level for now, just focus on understanding how the nodes that are documented work and developing on those unless explicitly told otherwise.</p>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/#ntrip-client","title":"<p> NTRIP Client </p>","text":"<p>This node is designed to take RTCM messages from a local RTCM provider and publish them out so our gps can use them as correctional data. The node is currently fully functional; however, we haven't yet figured out how to get the gps to register the messages properly. That is what the official gps node is for.</p>"},{"location":"ros2_packages/other_nodes/what_about_the_other_nodes/#official-gps","title":"<p> Official GPS </p>","text":"<p>This is a clone of the official ROS driver for our GPS series. The reason we did not use this from the start was a result of some weird choices Chris made for containerizing the entire project that didn't work with these drivers. This node works very similarly to our current GPS node; it simply listens for a GPS to plug into the device and publishes the results to a ROS topic. This ROS node, however has some other useful functionalities such as the ability to receive RTCM messages and use them as correctional data for our GPS.</p>"},{"location":"ros2_packages/sensors_package/gps/","title":"<p> GPS </p>","text":""},{"location":"ros2_packages/sensors_package/gps/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our GPS (Sparkfun NEO-M8P-2) and using various filtering techniques to clean the data and make it less noisy. Our GPS gives us both position and velocity data by tracking satellites in the sky, so performance may vary depending on how cloudy it is. </p> <p>We use the sparkfun-ublox-gps pip package to communicate with the gps, although in the future, we could look into the pyubx2 library as that seems to have more features. </p> <p>In the future we may also want to look into RTK (real time kinematics) to increase our GPS accuracy, but even without that, our GPS module is really precise with 0.5 meter accuracy! RTK would be nice though because it allows us to apply less aggressive filtering techniques and still get good results.</p> <p></p>"},{"location":"ros2_packages/sensors_package/gps/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run sensors gps\n</code></pre>"},{"location":"ros2_packages/sensors_package/rc/","title":"<p> RC (Remote Controller) </p>","text":""},{"location":"ros2_packages/sensors_package/rc/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our RC (remote controller). The remote controller that we use is the Radiomaster TX12 and the receiver that we use is the Radiomaster ER6. The communication protocol that we use is called CRSF with ExpressLRS, and we use the crsf_parser pip package to help us parse the crsf frames (frames are just a fancy way to say message packets).</p> <p>Here are some resources to understand the CRSF protocol: </p> <p>Useful reddit thread</p> <p>Source Code for an Arduino CRSF Parser</p> <p>:p Yeah thats it, there aren't many good resources unfortunately.</p> <p>If you would like to have some more resources on the receiver and transmitter they are available here:</p> <p>ER6 Receiver User Manual</p> <p>TX12 Quickstart Guide</p> <p>TX12 Transmitter User Manual</p> <p>Misc Radiomaster Documentation Collection (not necessary unless we want to buy another radiomaster product)</p> <p></p>"},{"location":"ros2_packages/sensors_package/rc/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run sensors rc\n</code></pre>"},{"location":"ros2_packages/sensors_package/wind_sensor/","title":"<p> Wind Sensor </p>","text":""},{"location":"ros2_packages/sensors_package/wind_sensor/#summary","title":"Summary","text":"<p>This node is responsible for communicating back and forth between our wind sensor (Calypso Wind Sensor). The wind sensor gives us NMEA0183 sentences that look may look like the picture below. </p> <p></p> <p>The NMEA0183 message structure is very simple. The basics are that they always send a \"$\" when the message starts and separates different sub-messages with commas. If you would like to read more about NMEA0183, you can do so here: NMEA0183 explanation.</p> <p></p> <p>Our wind sensor device sends its sub-messages in the following order: </p> <p></p>"},{"location":"ros2_packages/sensors_package/wind_sensor/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run wind_sensor wind_sensor\n</code></pre>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/","title":"<p> Sailboat Simulation </p>","text":""},{"location":"ros2_packages/simulation_package/sailboat_simulation/#summary","title":"Summary","text":"<p>The simulation node simulates all of the real world interactions that the boat will undergo without having to put the boat on the water. The simulation essentially takes the place of all of the sensor nodes and the microros nodes and should publish/ subscribe to the same things as those nodes. For more information on how the simulation interacts with everything else, please look at the system diagram for ros nodes for the simulation.</p>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/#how-it-works","title":"How it Works","text":"<p>The simulation node is basically a wrapper around the sailboat_gym repository, which can be found here: Sailboat Gym Github Repository. This repository basically has a docker container that all of the actual simulations happen in because there is a gazebo simulator for the sailboat inside of the docker container. The sailboat_gym repository then communicates with the docker container and controls the sailboat that exists inside of the docker container. The docker container is based off of the following repository: USV Sim LSA Github Repository, which is the gazebo environment that is run inside of the docker container. We can actually edit the docker container ourselves and have our own custom versions of the simulation, which is what I have set up the following repository for: Our Sailboat Simulation. In this github repository, you can edit the code for the simulation and then rebuild the docker image to be used whenever you use the simulation node. For more information, please look at the running a custom simulation documentation. You should also check out the system diagram for the simulation stack as it provides a visual explanation for how all of these pieces of code interact with each other.</p> <p>The simulation node simply imports the sailboat_gym repository and then ties specific actions to publishers and subscribers. For instance, if you publish a sail and rudder command, then the simulation node will pass that onto the sailboat_gym repository which will correspondingly control the boat in the simulation.</p> <p></p>"},{"location":"ros2_packages/simulation_package/sailboat_simulation/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run simulation simulation\n</code></pre>"},{"location":"ros2_packages/vesc_package/vesc/","title":"<p> VESC (Vedder Electric Speed Controller) </p>","text":""},{"location":"ros2_packages/vesc_package/vesc/#what-is-a-vesc","title":"What is a VESC?","text":"<p>A VESC is one type of electric speed controller, which regulate the speed and power that goes into our big propeller motor. VESCs are really only used for our motorboats, since motor controllers like these are usually overkill for the smaller motors in our sailboat. The big advantage of using a VESC controller instead of any random ESC controller is that the VESC firmware (which is the main thing that characterizes a VESC controller) provides a standardized way to send and receive complex control messages and telemetry data. It also has a lot of functionality built into the firware to allow for you to change voltage limits, shut-off voltages, PID constant values, encoder configurations, etc etc all from your computer or your phone via bluetooth. You can even change these things on the fly through custom software you can write. This is great! this means that we can write software to communicate with one ESC, and we guaranteed that it will work on another ESC that is running the VESC firmware. We are also assured that we can get a plethora of telemetry data back from a VESC on how much voltage our battery has, how much voltage/ current/ power is going to our motor, how much RPM our motor has, the temperature of our motor, etc.</p> <p>If it is not obvious yet, VESC is great and we would like to mainly buy VESC compatible ESCs whenever we would like to spec an ESC for a certain motor and desired system power. If you would like to read more about the wonders of VESC, you can do so here: VESC Tutorial and Other VESC Tutorial. If you would like to download VESC Tool which is the software that you can download on your computer or phone to configure and control the VESC without the VESC Node, you can do so here: VESC Tool Download.</p>"},{"location":"ros2_packages/vesc_package/vesc/#how-does-the-vesc-node-work","title":"How Does the VESC Node Work","text":"<p>The VESC node works by using an open source library called pyvesc, which is a python implementation that allows us to send and receive messages from the VESC over the USB serial port. The original pyvesc github can be found here: pyvesc github, and the documentation can be found here: pyvesc documentation</p> <p>For this project, we may want to modify the pyvesc library slightly to better suit our needs, so we have a modified version of the pyvesc library set up inside of the vesc package folder. Check out the documentation on custom libraries to learn more about how we use custom libraries in our ROS workspace.</p> <p>The VESC Node simply takes in ROS2 messages for the VESC control struct, and sends that information to the VESC controller whenever it receives the data from the autopilot. Meanwhile, the node also reads telemetry data from the VESC at a set interval and publishes it back out so that any node can listen in on the RPM, power, etc of the motor.</p> <p>I will go into a little bit of depth in how the VESC control struct works since it isn't completely obvious how it works. The VESC control struct has the following entries:</p> <p></p> <p>string control_type_for_vesc</p> <p>float32 desired_vesc_current</p> <p>float32 desired_vesc_rpm</p> <p>float32 desired_vesc_duty_cycle</p> <p></p> <p>The \"control_type_for_vesc\" can take on the following values: \"rpm\", \"duty_cycle\", or \"current\". Each of these are different ways to control the propeller motor by telling the VESC what you want the desired RPM to be, telling the VESC what you want the duty cycle (basically voltage to the motor) to be, or telling the VESC what you want the current to the motor to be. The VESC's job is to use the control type and your desired values, and get as close to that as possible; for the purposes of this project, how it does that is basically magic. </p> <p>If control_type_for_vesc is \"rpm\", then the only other entry in the struct that matters is the \"desired_vesc_rpm\" entry which tells the motor what the desired RPM is. All other entries are basically ignored. The same happens with the rest of the control types. So to summarize, only 2 of the entries in the struct ever matter at one time, and it depends on the value of the \"control_type_for_vesc\" string.</p> <p></p>"},{"location":"ros2_packages/vesc_package/vesc/#how-to-run","title":"How to Run","text":"<pre><code>ros2 run vesc vesc\n</code></pre>"},{"location":"system_diagrams/diagram_of_groundstation_telemetry/","title":"<p> Flow of Information Between Groundstation and Autopilot Node </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Flow of Telemetry Information Between Groundstation and Autopilot Node Source File Download</p>"},{"location":"system_diagrams/diagram_of_ros_nodes/","title":"<p> How Nodes Interact on the Sailboat Simulation </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat Simulation Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-sailboat-on-real-hardware","title":"<p> How Nodes Interact on the Sailboat on Real Hardware</p>","text":"<p>The following is the source file if you want to make edits to the diagram: Sailboat on Real Hardware Node Diagram Source File Download</p> <p></p>"},{"location":"system_diagrams/diagram_of_ros_nodes/#how-nodes-interact-on-the-motorboat-on-real-hardware","title":"<p> How Nodes Interact on the Motorboat on Real Hardware </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Motorboat on Real Hardware Node Diagram Source File Download</p>"},{"location":"system_diagrams/diagram_of_simulations/","title":"<p> How Each of the Different Codebases Contributing to the Simulation Interact </p>","text":"<p>The following is the source file if you want to make edits to the diagram: Simulation Diagram Source File Download</p>"}]}